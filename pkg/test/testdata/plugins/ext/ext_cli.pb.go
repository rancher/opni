// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/pkg/test/testdata/plugins/ext/ext.proto

package ext

import (
	context "context"
	errors "errors"
	cli "github.com/rancher/opni/internal/codegen/cli"
	cliutil "github.com/rancher/opni/pkg/opni/cliutil"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	v2 "github.com/thediveo/enumflag/v2"
	strings "strings"
)

type contextKey_Ext_type struct{}

var contextKey_Ext contextKey_Ext_type

func ContextWithExtClient(ctx context.Context, client ExtClient) context.Context {
	return context.WithValue(ctx, contextKey_Ext, client)
}

func ExtClientFromContext(ctx context.Context) (ExtClient, bool) {
	client, ok := ctx.Value(contextKey_Ext).(ExtClient)
	return client, ok
}

type contextKey_Ext2_type struct{}

var contextKey_Ext2 contextKey_Ext2_type

func ContextWithExt2Client(ctx context.Context, client Ext2Client) context.Context {
	return context.WithValue(ctx, contextKey_Ext2, client)
}

func Ext2ClientFromContext(ctx context.Context) (Ext2Client, bool) {
	client, ok := ctx.Value(contextKey_Ext2).(Ext2Client)
	return client, ok
}

var extraCmds_Ext []*cobra.Command

func addExtraExtCmd(custom *cobra.Command) {
	extraCmds_Ext = append(extraCmds_Ext, custom)
}

func BuildExtCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ext",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd,
		BuildExtFooCmd(),
		BuildExtFooCmd(),
		BuildExtFooCmd(),
		BuildExtFooCmd(),
	)
	cliutil.AddSubcommands(cmd, extraCmds_Ext...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildExtFooCmd() *cobra.Command {
	in := &FooRequest{}
	cmd := &cobra.Command{
		Use:   "foo",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /foo
- GET /foo
- PUT /foo
- DELETE /foo
- PATCH /foo
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := ExtClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Foo(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	return cmd
}

func BuildExtBarCmd() *cobra.Command {
	in := &BarRequest{}
	cmd := &cobra.Command{
		Use:   "bar",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /bar/{param1}/{param2}
- GET /bar/{param1}/{param2}/{param3}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := ExtClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Bar(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	return cmd
}

func BuildExtBazCmd() *cobra.Command {
	in := &BazRequest{}
	cmd := &cobra.Command{
		Use:   "baz",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /baz
- POST /baz/{paramMsg.paramBool}/{paramMsg.paramString}/{paramMsg.paramEnum}
- POST /baz/{paramMsg.paramMsg.paramMsg.paramMsg.paramString}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := ExtClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Baz(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.RegisterFlagCompletionFunc("param-enum", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"UNKNOWN", "FOO", "BAR"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func BuildExtSetCmd() *cobra.Command {
	in := &SetRequest{}
	cmd := &cobra.Command{
		Use:   "set",
		Short: "",
		Long: `
HTTP handlers for this method:
- PUT /set/{node.id}
- PUT /set/example/{node.id}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := ExtClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Set(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	return cmd
}

var extraCmds_Ext2 []*cobra.Command

func addExtraExt2Cmd(custom *cobra.Command) {
	extraCmds_Ext2 = append(extraCmds_Ext2, custom)
}

func BuildExt2Cmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ext-2",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cmd.AddCommand(BuildExt2FooCmd())
	cliutil.AddSubcommands(cmd, extraCmds_Ext2...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildExt2FooCmd() *cobra.Command {
	in := &FooRequest{}
	cmd := &cobra.Command{
		Use:               "foo",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := Ext2ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Foo(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	return cmd
}

func (in *FooRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("FooRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Request, strings.Join(append(prefix, "request"), "."), "", "")
	return fs
}

func (in *BarRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("BarRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Param1, strings.Join(append(prefix, "param-1"), "."), "", "")
	fs.StringVar(&in.Param2, strings.Join(append(prefix, "param-2"), "."), "", "")
	fs.StringVar(&in.Param3, strings.Join(append(prefix, "param-3"), "."), "", "")
	return fs
}

func (in *BazRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("BazRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Float64Var(&in.ParamFloat64, strings.Join(append(prefix, "param-float-64"), "."), 0.0, "")
	fs.Int64Var(&in.ParamInt64, strings.Join(append(prefix, "param-int-64"), "."), 0, "")
	fs.BoolVar(&in.ParamBool, strings.Join(append(prefix, "param-bool"), "."), false, "")
	fs.StringVar(&in.ParamString, strings.Join(append(prefix, "param-string"), "."), "", "")
	fs.BytesHexVar(&in.ParamBytes, strings.Join(append(prefix, "param-bytes"), "."), nil, "")
	fs.Var(v2.New(&in.ParamEnum, "BazEnum", map[BazRequest_BazEnum][]string{
		BazRequest_UNKNOWN: {"UNKNOWN"},
		BazRequest_FOO:     {"FOO"},
		BazRequest_BAR:     {"BAR"},
	}, v2.EnumCaseSensitive), strings.Join(append(prefix, "param-enum"), "."), "")
	fs.StringSliceVar(&in.ParamRepeatedString, strings.Join(append(prefix, "param-repeated-string"), "."), nil, "")
	if in.ParamMsg == nil {
		in.ParamMsg = &BazRequest{}
	}
	fs.AddFlagSet(in.ParamMsg.FlagSet(append(prefix, "param-msg")...))
	return fs
}

func (in *SetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Node == nil {
		in.Node = &Reference{}
	}
	fs.AddFlagSet(in.Node.FlagSet(append(prefix, "node")...))
	fs.StringVar(&in.Value, strings.Join(append(prefix, "value"), "."), "", "")
	if in.Example == nil {
		in.Example = &ExampleValue{}
	}
	fs.AddFlagSet(in.Example.FlagSet(append(prefix, "example")...))
	return fs
}

func (in *Reference) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Reference", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Id, strings.Join(append(prefix, "id"), "."), "", "")
	return fs
}

func (in *ExampleValue) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("ExampleValue", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Value, strings.Join(append(prefix, "value"), "."), "", "")
	return fs
}

func (in *FooResponse) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("FooResponse", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Response, strings.Join(append(prefix, "response"), "."), "", "")
	return fs
}

func (in *BarResponse) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("BarResponse", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Param1, strings.Join(append(prefix, "param-1"), "."), "", "")
	fs.StringVar(&in.Param2, strings.Join(append(prefix, "param-2"), "."), "", "")
	fs.StringVar(&in.Param3, strings.Join(append(prefix, "param-3"), "."), "", "")
	return fs
}

func (in *SampleConfiguration) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleConfiguration", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.StringField, strings.Join(append(prefix, "string-field"), "."), "", "")
	fs.StringVar(&in.SecretField, strings.Join(append(prefix, "secret-field"), "."), "", "\x1b[31m[secret]\x1b[0m ")
	fs.StringToStringVar(&in.MapField, strings.Join(append(prefix, "map-field"), "."), nil, "")
	fs.StringSliceVar(&in.RepeatedField, strings.Join(append(prefix, "repeated-field"), "."), nil, "")
	if in.MessageField == nil {
		in.MessageField = &SampleConfiguration{}
	}
	fs.AddFlagSet(in.MessageField.FlagSet(append(prefix, "message-field")...))
	return fs
}

func (in *SampleConfiguration) RedactSecrets() {
	if in == nil {
		return
	}
	if in.SecretField != "" {
		in.SecretField = "***"
	}
}

func (in *SampleConfiguration) UnredactSecrets(unredacted *SampleConfiguration) error {
	if in == nil {
		return nil
	}
	if in.SecretField == "***" {
		if unredacted.GetSecretField() == "" {
			return errors.New("cannot unredact: missing value for secret field: SecretField")
		}
		in.SecretField = unredacted.SecretField
	}
	return nil
}
