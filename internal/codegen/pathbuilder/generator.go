package pathbuilder

import (
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type PathBuilderGenerator struct {
	Roots []protoreflect.FullName
}

func (PathBuilderGenerator) Name() string {
	return "pathbuilder"
}

func (g PathBuilderGenerator) Generate(gen *protogen.Plugin) error {
	pathMap := make(map[protoreflect.FullName]struct{})
	for _, root := range g.Roots {
		pathMap[root] = struct{}{}
	}
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}
		toGenerate := []*protogen.Message{}
		for _, msg := range file.Messages {
			if _, ok := pathMap[msg.Desc.FullName()]; ok {
				toGenerate = append(toGenerate, msg)
			}
		}
		if len(toGenerate) == 0 {
			continue
		}
		g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+"_paths.pb.go", file.GoImportPath)
		generatePathBuilders(g, file, toGenerate)
	}
	return nil
}

func generatePathBuilders(g *protogen.GeneratedFile, f *protogen.File, messages []*protogen.Message) {
	g.P("// Code generated by internal/codegen/pathbuilder/generator.go. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())

	g.P()
	g.P("package ", f.GoPackageName)

	bx := &builderContext{
		seen: make(map[*protogen.Message]bool),
	}
	for _, msg := range messages {
		bx.generatePathBuilder(g, msg)
	}

	g.P("type (")
	for _, typ := range bx.types {
		g.P(typ...)
	}
	g.P(")")
	g.P()
	for _, root := range bx.roots {
		g.P(root...)
	}
	g.P()
	for _, fn := range bx.msgFuncs {
		g.P(fn...)
	}
	g.P()
	for _, fn := range bx.fieldFuncs {
		g.P(fn...)
	}
}

var (
	_protopath = protogen.GoImportPath("google.golang.org/protobuf/reflect/protopath")
)

type builderContext struct {
	seen       map[*protogen.Message]bool
	roots      [][]any
	types      [][]any
	msgFuncs   [][]any
	fieldFuncs [][]any
}

func (bx *builderContext) generatePathBuilder(g *protogen.GeneratedFile, msg *protogen.Message) {
	bx.roots = append(bx.roots,
		[]any{"func (*", msg.GoIdent.GoName, ") ProtoPath() ", unexport(msg.GoIdent.GoName), "PathBuilder {"},
		[]any{" return ", unexport(msg.GoIdent.GoName), "PathBuilder{protopath.Root(((*", msg.GoIdent, ")(nil)).ProtoReflect().Descriptor())}"},
		[]any{"}"},
	)

	bx.generatePathBuilderStruct(g, msg)
}

func (bx *builderContext) generatePathBuilderStruct(g *protogen.GeneratedFile, msg *protogen.Message) {
	if bx.seen[msg] {
		return
	}

	bx.seen[msg] = true

	nonMessageFields := []*protogen.Field{}
	messageFields := []*protogen.Field{}
	for _, fld := range msg.Fields {
		if fld.Desc.Kind() == protoreflect.MessageKind && !fld.Desc.IsMap() {
			messageFields = append(messageFields, fld)
		} else {
			nonMessageFields = append(nonMessageFields, fld)
		}
	}

	bx.types = append(bx.types, []any{unexport(msg.GoIdent.GoName), "PathBuilder ", _protopath.Ident("Path")})
	for _, fld := range messageFields {
		fld := fld
		if fld.Location.SourceFile != msg.Location.SourceFile {
			continue
		}
		bx.msgFuncs = append(bx.msgFuncs,
			[]any{"func (p ", unexport(msg.GoIdent.GoName), "PathBuilder) ", fld.GoName, "() ", unexport(fld.Message.GoIdent.GoName), "PathBuilder {"},
			[]any{" return ", unexport(fld.Message.GoIdent.GoName), "PathBuilder(append(p, ", _protopath.Ident("FieldAccess"), "(((*", msg.GoIdent, ")(nil)).ProtoReflect().Descriptor().Fields().ByNumber(", fld.Desc.Number(), "))))"},
			[]any{"}"},
		)
	}

	for _, fld := range nonMessageFields {
		fld := fld
		if fld.Location.SourceFile != msg.Location.SourceFile {
			continue
		}
		bx.fieldFuncs = append(bx.fieldFuncs,
			[]any{"func (p ", unexport(msg.GoIdent.GoName), "PathBuilder) ", fld.GoName, "() ", _protopath.Ident("Path"), "{"},
			[]any{" return ", _protopath.Ident("Path"), "(append(p, ", _protopath.Ident("FieldAccess"), "(((*", msg.GoIdent, ")(nil)).ProtoReflect().Descriptor().Fields().ByNumber(", fld.Desc.Number(), "))))"},
			[]any{"}"},
		)
	}

	for _, fld := range messageFields {
		bx.generatePathBuilderStruct(g, fld.Message)
	}
}

func unexport(s string) string {
	if len(s) == 0 {
		return ""
	}
	return string(unicode.ToLower(rune(s[0]))) + s[1:]
}
