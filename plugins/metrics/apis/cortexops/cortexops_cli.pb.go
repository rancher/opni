// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/plugins/metrics/apis/cortexops/cortexops.proto

package cortexops

import (
	context "context"
	cli "github.com/rancher/opni/internal/codegen/cli"
	compactor "github.com/rancher/opni/internal/cortex/config/compactor"
	querier "github.com/rancher/opni/internal/cortex/config/querier"
	runtimeconfig "github.com/rancher/opni/internal/cortex/config/runtimeconfig"
	validation "github.com/rancher/opni/internal/cortex/config/validation"
	v1 "github.com/rancher/opni/pkg/apis/storage/v1"
	cliutil "github.com/rancher/opni/pkg/opni/cliutil"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	strings "strings"
)

type contextKey_CortexOps_type struct{}

var contextKey_CortexOps contextKey_CortexOps_type

func ContextWithCortexOpsClient(ctx context.Context, client CortexOpsClient) context.Context {
	return context.WithValue(ctx, contextKey_CortexOps, client)
}

func CortexOpsClientFromContext(ctx context.Context) (CortexOpsClient, bool) {
	client, ok := ctx.Value(contextKey_CortexOps).(CortexOpsClient)
	return client, ok
}

var extraCmds_CortexOps []*cobra.Command

func addExtraCortexOpsCmd(custom *cobra.Command) {
	extraCmds_CortexOps = append(extraCmds_CortexOps, custom)
}

func BuildCortexOpsCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ops",
		Short:             `The CortexOps service contains setup and configuration lifecycle actions for the managed Cortex cluster.`,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd,
		BuildCortexOpsGetDefaultConfigurationCmd(),
		BuildCortexOpsSetDefaultConfigurationCmd(),
		BuildCortexOpsResetDefaultConfigurationCmd(),
		BuildCortexOpsGetConfigurationCmd(),
		BuildCortexOpsSetConfigurationCmd(),
		BuildCortexOpsResetConfigurationCmd(),
		BuildCortexOpsStatusCmd(),
		BuildCortexOpsInstallCmd(),
		BuildCortexOpsUninstallCmd(),
		BuildCortexOpsListPresetsCmd(),
	)
	cliutil.AddSubcommands(cmd, extraCmds_CortexOps...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildCortexOpsGetDefaultConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config get-default",
		Short: "Returns the default implementation-specific configuration, or one previously set.",
		Long: `
If a default configuration was previously set using SetDefaultConfiguration, it
returns that configuration. Otherwise, returns implementation-specific defaults.

HTTP handlers for this method:
- GET /configuration/default
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.GetDefaultConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsSetDefaultConfigurationCmd() *cobra.Command {
	in := &CapabilityBackendConfigSpec{}
	cmd := &cobra.Command{
		Use:   "config set-default",
		Short: "Sets the default configuration that will be used as the base for future configuration changes.",
		Long: `
If no custom default configuration is set using this method,
implementation-specific defaults may be chosen.
If all fields are unset, this will clear any previously-set default configuration
and revert back to the implementation-specific defaults.

This API is different from the SetConfiguration API, and should not be necessary
for most use cases. It can be used in situations where an additional persistence
layer that is not driver-specific is desired.

HTTP handlers for this method:
- PUT /configuration/default
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if curValue, err := client.GetDefaultConfiguration(cmd.Context(), &emptypb.Empty{}); err == nil {
				in = curValue
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.SetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.RegisterFlagCompletionFunc("cortex-config.storage.backend", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"filesystem", "s3", "gcs", "azure", "swift"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func BuildCortexOpsResetDefaultConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config reset-default",
		Short: "Resets the default configuration to the implementation-specific defaults.",
		Long: `
If a custom default configuration was previously set using SetDefaultConfiguration,
this will clear it and revert back to the implementation-specific defaults.
Otherwise, this will have no effect.

HTTP handlers for this method:
- DELETE /configuration/default
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.ResetDefaultConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsGetConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config get",
		Short: "Gets the current configuration of the managed Cortex cluster.",
		Long: `
HTTP handlers for this method:
- GET /configuration
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.GetConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsSetConfigurationCmd() *cobra.Command {
	in := &CapabilityBackendConfigSpec{}
	cmd := &cobra.Command{
		Use:   "config set",
		Short: "Updates the configuration of the managed Cortex cluster to match the provided configuration.",
		Long: `
If the cluster is not installed, it will be configured, but remain disabled.
Otherwise, the already-installed cluster will be reconfigured.
The provided configuration will be merged with the default configuration
by directly overwriting fields. Slices and maps are overwritten and not combined.
Subsequent calls to this API will merge inputs with the current configuration,
not the default configuration.

Note: some fields may contain secrets. The placeholder value "***" can be used to
keep an existing secret when updating the cluster configuration.

HTTP handlers for this method:
- PUT /configuration
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if curValue, err := client.GetDefaultConfiguration(cmd.Context(), &emptypb.Empty{}); err == nil {
				in = curValue
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.SetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.RegisterFlagCompletionFunc("cortex-config.storage.backend", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"filesystem", "s3", "gcs", "azure", "swift"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func BuildCortexOpsResetConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config reset",
		Short: "Resets the configuration of the managed Cortex cluster to the current default configuration.",
		Long: `
HTTP handlers for this method:
- DELETE /configuration
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.ResetConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsStatusCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "status",
		Short: "Gets the current status of the managed Cortex cluster.",
		Long: `
The status includes the current install state, version, and metadata. If
the cluster is in the process of being reconfigured or uninstalled, it will
be reflected in the install state.
No guarantees are made about the contents of the metadata field; its
contents are strictly informational.

HTTP handlers for this method:
- GET /status
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Status(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsInstallCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "install",
		Short: "Installs the managed Cortex cluster.",
		Long: `
The cluster will be installed using the current configuration, or the
default configuration if none is explicitly set.

HTTP handlers for this method:
- POST /install
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.Install(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsUninstallCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "uninstall",
		Short: "Uninstalls the managed Cortex cluster.",
		Long: `
Implementation details including error handling and system state requirements
are left to the cluster driver, and this API makes no guarantees about
the state of the cluster after the call completes (regardless of success).

HTTP handlers for this method:
- POST /uninstall
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.Uninstall(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildCortexOpsListPresetsCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "presets list",
		Short: "Returns a static list of presets that can be used as a base for configuring the managed Cortex cluster.",
		Long: `
There are several ways to use the presets, depending
on the desired behavior:
1. Set the default configuration to a preset spec, then use SetConfiguration
to fill in any additional required fields (credentials, etc)
2. Add the required fields to the default configuration, then use
SetConfiguration with a preset spec.
3. Leave the default configuration as-is, and use SetConfiguration with a
preset spec plus the required fields.

HTTP handlers for this method:
- GET /presets
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, argenerateArgsgs []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.ListPresets(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func (in *CapabilityBackendConfigSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("CapabilityBackendConfigSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.BoolPtrValue(&in.Enabled), strings.Join(append(prefix, "enabled"), "."), "")
	if in.CortexWorkloads == nil {
		in.CortexWorkloads = &CortexWorkloadsConfig{}
	}
	fs.AddFlagSet(in.CortexWorkloads.FlagSet(append(prefix, "cortex-workloads")...))
	if in.CortexConfig == nil {
		in.CortexConfig = &CortexApplicationConfig{}
	}
	fs.AddFlagSet(in.CortexConfig.FlagSet(append(prefix, "cortex-config")...))
	if in.Grafana == nil {
		in.Grafana = &GrafanaConfig{}
	}
	fs.AddFlagSet(in.Grafana.FlagSet(append(prefix, "grafana")...))
	return fs
}

func (in *CapabilityBackendConfigSpec) RedactSecrets() {
	if in == nil {
		return
	}
	in.CortexConfig.RedactSecrets()
}

func (in *CapabilityBackendConfigSpec) UnredactSecrets(unredacted *CapabilityBackendConfigSpec) error {
	if in == nil {
		return nil
	}
	if err := in.CortexConfig.UnredactSecrets(unredacted.GetCortexConfig()); err != nil {
		return err
	}
	return nil
}

func (in *CortexWorkloadsConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("CortexWorkloadsConfig", pflag.ExitOnError)
	fs.SortFlags = true
	return fs
}

func (in *CortexApplicationConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("CortexApplicationConfig", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Limits == nil {
		in.Limits = &validation.Limits{}
	}
	fs.AddFlagSet(in.Limits.FlagSet(append(prefix, "limits")...))
	fs.Lookup(strings.Join(append(prefix, "limits", "ingestion-rate"), ".")).DefValue = "600000"
	fs.Lookup(strings.Join(append(prefix, "limits", "ingestion-burst-size"), ".")).DefValue = "1000000"
	fs.Lookup(strings.Join(append(prefix, "limits", "compactor-blocks-retention-period"), ".")).DefValue = "seconds:2592000"
	if in.RuntimeConfig == nil {
		in.RuntimeConfig = &runtimeconfig.RuntimeConfigValues{}
	}
	fs.AddFlagSet(in.RuntimeConfig.FlagSet(append(prefix, "runtime-config")...))
	if in.Compactor == nil {
		in.Compactor = &compactor.Config{}
	}
	fs.AddFlagSet(in.Compactor.FlagSet(append(prefix, "compactor")...))
	if in.Querier == nil {
		in.Querier = &querier.Config{}
	}
	fs.AddFlagSet(in.Querier.FlagSet(append(prefix, "querier")...))
	fs.StringVar(&in.LogLevel, strings.Join(append(prefix, "log-level"), "."), "", "")
	if in.Storage == nil {
		in.Storage = &v1.StorageSpec{}
	}
	fs.AddFlagSet(in.Storage.FlagSet(append(prefix, "storage")...))
	return fs
}

func (in *CortexApplicationConfig) RedactSecrets() {
	if in == nil {
		return
	}
	in.Storage.RedactSecrets()
}

func (in *CortexApplicationConfig) UnredactSecrets(unredacted *CortexApplicationConfig) error {
	if in == nil {
		return nil
	}
	if err := in.Storage.UnredactSecrets(unredacted.GetStorage()); err != nil {
		return err
	}
	return nil
}

func (in *GrafanaConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("GrafanaConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.BoolVar(&in.Enabled, strings.Join(append(prefix, "enabled"), "."), false, "Whether to deploy a managed Grafana instance.")
	fs.StringVar(&in.Version, strings.Join(append(prefix, "version"), "."), "latest", "The version of Grafana to deploy.")
	fs.StringVar(&in.Hostname, strings.Join(append(prefix, "hostname"), "."), "", "")
	return fs
}

func (in *InstallStatus) DeepCopyInto(out *InstallStatus) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *InstallStatus) DeepCopy() *InstallStatus {
	return proto.Clone(in).(*InstallStatus)
}

func (in *CapabilityBackendConfigSpec) DeepCopyInto(out *CapabilityBackendConfigSpec) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *CapabilityBackendConfigSpec) DeepCopy() *CapabilityBackendConfigSpec {
	return proto.Clone(in).(*CapabilityBackendConfigSpec)
}

func (in *CortexWorkloadsConfig) DeepCopyInto(out *CortexWorkloadsConfig) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *CortexWorkloadsConfig) DeepCopy() *CortexWorkloadsConfig {
	return proto.Clone(in).(*CortexWorkloadsConfig)
}

func (in *CortexWorkloadSpec) DeepCopyInto(out *CortexWorkloadSpec) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *CortexWorkloadSpec) DeepCopy() *CortexWorkloadSpec {
	return proto.Clone(in).(*CortexWorkloadSpec)
}

func (in *CortexApplicationConfig) DeepCopyInto(out *CortexApplicationConfig) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *CortexApplicationConfig) DeepCopy() *CortexApplicationConfig {
	return proto.Clone(in).(*CortexApplicationConfig)
}

func (in *GrafanaConfig) DeepCopyInto(out *GrafanaConfig) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *GrafanaConfig) DeepCopy() *GrafanaConfig {
	return proto.Clone(in).(*GrafanaConfig)
}

func (in *PresetList) DeepCopyInto(out *PresetList) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *PresetList) DeepCopy() *PresetList {
	return proto.Clone(in).(*PresetList)
}

func (in *Preset) DeepCopyInto(out *Preset) {
	out.Reset()
	proto.Merge(out, in)
}

func (in *Preset) DeepCopy() *Preset {
	return proto.Clone(in).(*Preset)
}
