// Code generated by internal/codegen/cli/generator.go. DO NOT EDIT.
// source: github.com/rancher/opni/pkg/test/testdata/plugins/ext/ext.proto

package ext

import (
	context "context"
	errors "errors"
	cli "github.com/rancher/opni/internal/codegen/cli"
	v1 "github.com/rancher/opni/pkg/apis/core/v1"
	cliutil "github.com/rancher/opni/pkg/opni/cliutil"
	driverutil "github.com/rancher/opni/pkg/plugins/driverutil"
	storage "github.com/rancher/opni/pkg/storage"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	lo "github.com/samber/lo"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	errdetails "google.golang.org/genproto/googleapis/rpc/errdetails"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	strings "strings"
)

type (
	contextKey_Ext_type      struct{}
	contextInjector_Ext_type struct{}
)

var (
	contextKey_Ext     contextKey_Ext_type
	ExtContextInjector contextInjector_Ext_type
)

func (contextInjector_Ext_type) NewClient(cc grpc.ClientConnInterface) ExtClient {
	return NewExtClient(cc)
}

func (contextInjector_Ext_type) UnderlyingConn(client ExtClient) grpc.ClientConnInterface {
	return client.(*extClient).cc
}

func (contextInjector_Ext_type) ContextWithClient(ctx context.Context, client ExtClient) context.Context {
	return context.WithValue(ctx, contextKey_Ext, client)
}

func (contextInjector_Ext_type) ClientFromContext(ctx context.Context) (ExtClient, bool) {
	client, ok := ctx.Value(contextKey_Ext).(ExtClient)
	return client, ok
}

type (
	contextKey_Config_type      struct{}
	contextInjector_Config_type struct{}
)

var (
	contextKey_Config     contextKey_Config_type
	ConfigContextInjector contextInjector_Config_type
)

func (contextInjector_Config_type) NewClient(cc grpc.ClientConnInterface) ConfigClient {
	return NewConfigClient(cc)
}

func (contextInjector_Config_type) UnderlyingConn(client ConfigClient) grpc.ClientConnInterface {
	return client.(*configClient).cc
}

func (contextInjector_Config_type) ContextWithClient(ctx context.Context, client ConfigClient) context.Context {
	return context.WithValue(ctx, contextKey_Config, client)
}

func (contextInjector_Config_type) ClientFromContext(ctx context.Context) (ConfigClient, bool) {
	client, ok := ctx.Value(contextKey_Config).(ConfigClient)
	return client, ok
}

type (
	contextKey_Ext2_type      struct{}
	contextInjector_Ext2_type struct{}
)

var (
	contextKey_Ext2     contextKey_Ext2_type
	Ext2ContextInjector contextInjector_Ext2_type
)

func (contextInjector_Ext2_type) NewClient(cc grpc.ClientConnInterface) Ext2Client {
	return NewExt2Client(cc)
}

func (contextInjector_Ext2_type) UnderlyingConn(client Ext2Client) grpc.ClientConnInterface {
	return client.(*ext2Client).cc
}

func (contextInjector_Ext2_type) ContextWithClient(ctx context.Context, client Ext2Client) context.Context {
	return context.WithValue(ctx, contextKey_Ext2, client)
}

func (contextInjector_Ext2_type) ClientFromContext(ctx context.Context) (Ext2Client, bool) {
	client, ok := ctx.Value(contextKey_Ext2).(Ext2Client)
	return client, ok
}

var extraCmds_Ext []*cobra.Command

func addExtraExtCmd(custom *cobra.Command) {
	extraCmds_Ext = append(extraCmds_Ext, custom)
}

func BuildExtCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ext",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd, append([]*cobra.Command{
		BuildExtFooCmd(),
		BuildExtBarCmd(),
		BuildExtBazCmd(),
		BuildExtSetCmd(),
	}, extraCmds_Ext...)...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildExtFooCmd() *cobra.Command {
	in := &FooRequest{}
	cmd := &cobra.Command{
		Use:   "foo",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /foo
- GET /foo
- PUT /foo
- DELETE /foo
- PATCH /foo
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExtContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Foo(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildExtBarCmd() *cobra.Command {
	in := &BarRequest{}
	cmd := &cobra.Command{
		Use:   "bar",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /bar/{param1}/{param2}
- GET /bar/{param1}/{param2}/{param3}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExtContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Bar(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildExtBazCmd() *cobra.Command {
	in := &BazRequest{}
	cmd := &cobra.Command{
		Use:   "baz",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /baz
- POST /baz/{paramMsg.paramBool}/{paramMsg.paramString}/{paramMsg.paramEnum}
- POST /baz/{paramMsg.paramMsg.paramMsg.paramMsg.paramString}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExtContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Baz(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.RegisterFlagCompletionFunc("param-enum", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"UNKNOWN", "FOO", "BAR"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func BuildExtSetCmd() *cobra.Command {
	in := &SetRequest{}
	cmd := &cobra.Command{
		Use:   "set",
		Short: "",
		Long: `
HTTP handlers for this method:
- PUT /set/{node.id}
- PUT /set/example/{node.id}
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExtContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Set(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

var extraCmds_Config []*cobra.Command

func addExtraConfigCmd(custom *cobra.Command) {
	extraCmds_Config = append(extraCmds_Config, custom)
}

func BuildConfigCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "config",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd, append([]*cobra.Command{
		BuildConfigGetDefaultConfigurationCmd(),
		BuildConfigSetDefaultConfigurationCmd(),
		BuildConfigGetConfigurationCmd(),
		BuildConfigSetConfigurationCmd(),
		BuildConfigResetDefaultConfigurationCmd(),
		BuildConfigResetConfigurationCmd(),
		BuildConfigConfigurationHistoryCmd(),
	}, extraCmds_Config...)...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildConfigGetDefaultConfigurationCmd() *cobra.Command {
	in := &SampleGetRequest{}
	cmd := &cobra.Command{
		Use:               "get-default",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.GetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildConfigSetDefaultConfigurationCmd() *cobra.Command {
	in := &SampleSetRequest{}
	cmd := &cobra.Command{
		Use:               "set-default",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if curValue, err := client.GetDefaultConfiguration(cmd.Context(), &SampleGetRequest{}); err == nil {
					in.Spec = curValue
				}
				if edited, err := cliutil.EditInteractive(in.Spec); err != nil {
					return err
				} else {
					in.Spec = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if in.Spec == nil {
					cliutil.InitializeField(&in.Spec)
				}
				if err := cliutil.LoadFromFile(in.Spec, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.SetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildConfigGetConfigurationCmd() *cobra.Command {
	in := &SampleGetRequest{}
	cmd := &cobra.Command{
		Use:               "get",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.GetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildConfigSetConfigurationCmd() *cobra.Command {
	in := &SampleSetRequest{}
	cmd := &cobra.Command{
		Use:               "set",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if curValue, err := client.GetConfiguration(cmd.Context(), &SampleGetRequest{}); err == nil {
					in.Spec = curValue
				}
				if edited, err := cliutil.EditInteractive(in.Spec); err != nil {
					return err
				} else {
					in.Spec = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if in.Spec == nil {
					cliutil.InitializeField(&in.Spec)
				}
				if err := cliutil.LoadFromFile(in.Spec, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.SetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildConfigResetDefaultConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "reset-default",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.ResetDefaultConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildConfigResetConfigurationCmd() *cobra.Command {
	in := &SampleResetRequest{}
	cmd := &cobra.Command{
		Use:               "reset",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if err := cliutil.LoadFromFile(in, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.ResetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildConfigConfigurationHistoryCmd() *cobra.Command {
	in := &SampleHistoryRequest{}
	cmd := &cobra.Command{
		Use:               "history",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.ConfigurationHistory(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.RegisterFlagCompletionFunc("target", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"ActiveConfiguration", "DefaultConfiguration"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

var extraCmds_Ext2 []*cobra.Command

func addExtraExt2Cmd(custom *cobra.Command) {
	extraCmds_Ext2 = append(extraCmds_Ext2, custom)
}

func BuildExt2Cmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ext-2",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cmd.AddCommand(BuildExt2FooCmd())
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildExt2FooCmd() *cobra.Command {
	in := &FooRequest{}
	cmd := &cobra.Command{
		Use:               "foo",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := Ext2ContextInjector.ClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Foo(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func (in *FooRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("FooRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Request, strings.Join(append(prefix, "request"), "."), "", "")
	return fs
}

func (in *BarRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("BarRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Param1, strings.Join(append(prefix, "param-1"), "."), "", "")
	fs.StringVar(&in.Param2, strings.Join(append(prefix, "param-2"), "."), "", "")
	fs.StringVar(&in.Param3, strings.Join(append(prefix, "param-3"), "."), "", "")
	return fs
}

func (in *BazRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("BazRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Float64Var(&in.ParamFloat64, strings.Join(append(prefix, "param-float-64"), "."), 0.0, "")
	fs.Int64Var(&in.ParamInt64, strings.Join(append(prefix, "param-int-64"), "."), 0, "")
	fs.BoolVar(&in.ParamBool, strings.Join(append(prefix, "param-bool"), "."), false, "")
	fs.StringVar(&in.ParamString, strings.Join(append(prefix, "param-string"), "."), "", "")
	fs.BytesHexVar(&in.ParamBytes, strings.Join(append(prefix, "param-bytes"), "."), nil, "")
	fs.Var(flagutil.EnumValue(BazRequest_UNKNOWN, &in.ParamEnum), strings.Join(append(prefix, "param-enum"), "."), "")
	fs.Var(flagutil.DurationpbValue(nil, &in.ParamDuration), strings.Join(append(prefix, "param-duration"), "."), "")
	fs.StringSliceVar(&in.ParamRepeatedString, strings.Join(append(prefix, "param-repeated-string"), "."), nil, "")
	return fs
}

func (in *SetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Node == nil {
		in.Node = &Reference{}
	}
	fs.AddFlagSet(in.Node.FlagSet(append(prefix, "node")...))
	fs.StringVar(&in.Value, strings.Join(append(prefix, "value"), "."), "", "")
	if in.Example == nil {
		in.Example = &ExampleValue{}
	}
	fs.AddFlagSet(in.Example.FlagSet(append(prefix, "example")...))
	return fs
}

func (in *Reference) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Reference", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Id, strings.Join(append(prefix, "id"), "."), "", "")
	return fs
}

func (in *ExampleValue) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("ExampleValue", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Value, strings.Join(append(prefix, "value"), "."), "", "")
	return fs
}

func (in *SampleGetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleGetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.StringPtrValue(nil, &in.Key), strings.Join(append(prefix, "key"), "."), "")
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(prefix...))
	return fs
}

func (in *SampleSetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleSetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.StringPtrValue(nil, &in.Key), strings.Join(append(prefix, "key"), "."), "")
	if in.Spec == nil {
		in.Spec = &SampleConfiguration{}
	}
	fs.AddFlagSet(in.Spec.FlagSet(append(prefix, "spec")...))
	return fs
}

func (in *SampleSetRequest) RedactSecrets() {
	if in == nil {
		return
	}
	in.Spec.RedactSecrets()
}

func (in *SampleSetRequest) UnredactSecrets(unredacted *SampleSetRequest) error {
	if in == nil {
		return nil
	}
	var details []protoiface.MessageV1
	if err := in.Spec.UnredactSecrets(unredacted.GetSpec()); storage.IsDiscontinuity(err) {
		for _, sd := range status.Convert(err).Details() {
			if info, ok := sd.(*errdetails.ErrorInfo); ok {
				info.Metadata["field"] = "spec." + info.Metadata["field"]
				details = append(details, info)
			}
		}
	}
	if len(details) == 0 {
		return nil
	}
	return lo.Must(status.New(codes.InvalidArgument, "cannot unredact: missing values for secret fields").WithDetails(details...)).Err()
}

func (in *SampleConfiguration) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleConfiguration", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(append(prefix, "revision")...))
	fs.Var(flagutil.StringPtrValue(nil, &in.StringField), strings.Join(append(prefix, "string-field"), "."), "")
	fs.Var(flagutil.StringPtrValue(nil, &in.SecretField), strings.Join(append(prefix, "secret-field"), "."), "\x1b[31m[secret]\x1b[0m ")
	fs.StringToStringVar(&in.MapField, strings.Join(append(prefix, "map-field"), "."), nil, "")
	fs.StringSliceVar(&in.RepeatedField, strings.Join(append(prefix, "repeated-field"), "."), nil, "")
	if in.MessageField == nil {
		in.MessageField = &SampleMessage{}
	}
	fs.AddFlagSet(in.MessageField.FlagSet(append(prefix, "message-field")...))
	return fs
}

func (in *SampleConfiguration) RedactSecrets() {
	if in == nil {
		return
	}
	if in.GetSecretField() != "" {
		in.SecretField = flagutil.Ptr("***")
	}
}

func (in *SampleConfiguration) UnredactSecrets(unredacted *SampleConfiguration) error {
	if in == nil {
		return nil
	}
	var details []protoiface.MessageV1
	if in.GetSecretField() == "***" {
		if unredacted.GetSecretField() == "" {
			details = append(details, &errdetails.ErrorInfo{
				Reason:   "DISCONTINUITY",
				Metadata: map[string]string{"field": "secretField"},
			})
		} else {
			*in.SecretField = *unredacted.SecretField
		}
	}
	if len(details) == 0 {
		return nil
	}
	return lo.Must(status.New(codes.InvalidArgument, "cannot unredact: missing values for secret fields").WithDetails(details...)).Err()
}

func (in *SampleMessage) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleMessage", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Field1 == nil {
		in.Field1 = &Sample1FieldMsg{}
	}
	fs.AddFlagSet(in.Field1.FlagSet(append(prefix, "field-1")...))
	if in.Field2 == nil {
		in.Field2 = &Sample2FieldMsg{}
	}
	fs.AddFlagSet(in.Field2.FlagSet(append(prefix, "field-2")...))
	if in.Field3 == nil {
		in.Field3 = &Sample3FieldMsg{}
	}
	fs.AddFlagSet(in.Field3.FlagSet(append(prefix, "field-3")...))
	if in.Field4 == nil {
		in.Field4 = &Sample4FieldMsg{}
	}
	fs.AddFlagSet(in.Field4.FlagSet(append(prefix, "field-4")...))
	if in.Field5 == nil {
		in.Field5 = &Sample5FieldMsg{}
	}
	fs.AddFlagSet(in.Field5.FlagSet(append(prefix, "field-5")...))
	if in.Field6 == nil {
		in.Field6 = &Sample6FieldMsg{}
	}
	fs.AddFlagSet(in.Field6.FlagSet(append(prefix, "field-6")...))
	if in.Msg == nil {
		in.Msg = &SampleMessage2{}
	}
	fs.AddFlagSet(in.Msg.FlagSet(append(prefix, "msg")...))
	return fs
}

func (in *Sample1FieldMsg) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Sample1FieldMsg", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.Field1, strings.Join(append(prefix, "field-1"), "."), 0, "")
	return fs
}

func (in *Sample2FieldMsg) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Sample2FieldMsg", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.Field1, strings.Join(append(prefix, "field-1"), "."), 0, "")
	fs.Int32Var(&in.Field2, strings.Join(append(prefix, "field-2"), "."), 0, "")
	return fs
}

func (in *Sample3FieldMsg) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Sample3FieldMsg", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.Field1, strings.Join(append(prefix, "field-1"), "."), 0, "")
	fs.Int32Var(&in.Field2, strings.Join(append(prefix, "field-2"), "."), 0, "")
	fs.Int32Var(&in.Field3, strings.Join(append(prefix, "field-3"), "."), 0, "")
	return fs
}

func (in *Sample4FieldMsg) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Sample4FieldMsg", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.Field1, strings.Join(append(prefix, "field-1"), "."), 0, "")
	fs.Int32Var(&in.Field2, strings.Join(append(prefix, "field-2"), "."), 0, "")
	fs.Int32Var(&in.Field3, strings.Join(append(prefix, "field-3"), "."), 0, "")
	fs.Int32Var(&in.Field4, strings.Join(append(prefix, "field-4"), "."), 0, "")
	return fs
}

func (in *Sample5FieldMsg) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Sample5FieldMsg", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.Field1, strings.Join(append(prefix, "field-1"), "."), 0, "")
	fs.Int32Var(&in.Field2, strings.Join(append(prefix, "field-2"), "."), 0, "")
	fs.Int32Var(&in.Field3, strings.Join(append(prefix, "field-3"), "."), 0, "")
	fs.Int32Var(&in.Field4, strings.Join(append(prefix, "field-4"), "."), 0, "")
	fs.Int32Var(&in.Field5, strings.Join(append(prefix, "field-5"), "."), 0, "")
	return fs
}

func (in *Sample6FieldMsg) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Sample6FieldMsg", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.Field1, strings.Join(append(prefix, "field-1"), "."), 0, "")
	fs.Int32Var(&in.Field2, strings.Join(append(prefix, "field-2"), "."), 0, "")
	fs.Int32Var(&in.Field3, strings.Join(append(prefix, "field-3"), "."), 0, "")
	fs.Int32Var(&in.Field4, strings.Join(append(prefix, "field-4"), "."), 0, "")
	fs.Int32Var(&in.Field5, strings.Join(append(prefix, "field-5"), "."), 0, "")
	fs.Int32Var(&in.Field6, strings.Join(append(prefix, "field-6"), "."), 0, "")
	return fs
}

func (in *SampleMessage2) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleMessage2", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Field1 == nil {
		in.Field1 = &Sample1FieldMsg{}
	}
	fs.AddFlagSet(in.Field1.FlagSet(append(prefix, "field-1")...))
	if in.Field2 == nil {
		in.Field2 = &Sample2FieldMsg{}
	}
	fs.AddFlagSet(in.Field2.FlagSet(append(prefix, "field-2")...))
	if in.Field3 == nil {
		in.Field3 = &Sample3FieldMsg{}
	}
	fs.AddFlagSet(in.Field3.FlagSet(append(prefix, "field-3")...))
	if in.Field4 == nil {
		in.Field4 = &Sample4FieldMsg{}
	}
	fs.AddFlagSet(in.Field4.FlagSet(append(prefix, "field-4")...))
	if in.Field5 == nil {
		in.Field5 = &Sample5FieldMsg{}
	}
	fs.AddFlagSet(in.Field5.FlagSet(append(prefix, "field-5")...))
	if in.Field6 == nil {
		in.Field6 = &Sample6FieldMsg{}
	}
	fs.AddFlagSet(in.Field6.FlagSet(append(prefix, "field-6")...))
	return fs
}

func (in *SampleResetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleResetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.StringPtrValue(nil, &in.Key), strings.Join(append(prefix, "key"), "."), "")
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(prefix...))
	return fs
}

func (in *SampleHistoryRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleHistoryRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.StringPtrValue(nil, &in.Key), strings.Join(append(prefix, "key"), "."), "")
	fs.Var(flagutil.EnumValue(driverutil.Target_ActiveConfiguration, &in.Target), strings.Join(append(prefix, "target"), "."), "")
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(prefix...))
	fs.BoolVar(&in.IncludeValues, strings.Join(append(prefix, "include-values"), "."), true, "")
	return fs
}

func (in *FooResponse) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("FooResponse", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Response, strings.Join(append(prefix, "response"), "."), "", "")
	return fs
}

func (in *BarResponse) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("BarResponse", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Param1, strings.Join(append(prefix, "param-1"), "."), "", "")
	fs.StringVar(&in.Param2, strings.Join(append(prefix, "param-2"), "."), "", "")
	fs.StringVar(&in.Param3, strings.Join(append(prefix, "param-3"), "."), "", "")
	return fs
}

func (in *SampleDryRunRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleDryRunRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.StringPtrValue(nil, &in.Key), strings.Join(append(prefix, "key"), "."), "")
	fs.Var(flagutil.EnumValue(driverutil.Target_ActiveConfiguration, &in.Target), strings.Join(append(prefix, "target"), "."), "")
	fs.Var(flagutil.EnumValue(driverutil.Action_NoAction, &in.Action), strings.Join(append(prefix, "action"), "."), "")
	if in.Spec == nil {
		in.Spec = &SampleConfiguration{}
	}
	fs.AddFlagSet(in.Spec.FlagSet(append(prefix, "spec")...))
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(append(prefix, "revision")...))
	return fs
}

func (in *SampleDryRunRequest) RedactSecrets() {
	if in == nil {
		return
	}
	in.Spec.RedactSecrets()
}

func (in *SampleDryRunRequest) UnredactSecrets(unredacted *SampleDryRunRequest) error {
	if in == nil {
		return nil
	}
	var details []protoiface.MessageV1
	if err := in.Spec.UnredactSecrets(unredacted.GetSpec()); storage.IsDiscontinuity(err) {
		for _, sd := range status.Convert(err).Details() {
			if info, ok := sd.(*errdetails.ErrorInfo); ok {
				info.Metadata["field"] = "spec." + info.Metadata["field"]
				details = append(details, info)
			}
		}
	}
	if len(details) == 0 {
		return nil
	}
	return lo.Must(status.New(codes.InvalidArgument, "cannot unredact: missing values for secret fields").WithDetails(details...)).Err()
}

func (in *SampleConfigurationHistoryResponse) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SampleConfigurationHistoryResponse", pflag.ExitOnError)
	fs.SortFlags = true
	return fs
}
