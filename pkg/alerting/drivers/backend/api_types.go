package backend

/*
Autogenerated API structs based on AlertManager's openapi spec.
*/

import (
	"fmt"
	"time"

	"github.com/go-openapi/strfmt"
)

// AlertGroup struct for AlertGroup
type AlertGroup struct {
	Labels   map[string]string `json:"labels"`
	Receiver Receiver          `json:"receiver"`
	Alerts   []GettableAlert   `json:"alerts"`
}

// GettableAlert gettable alert
//
// swagger:model gettableAlert
type GettableAlert struct {

	// annotations
	// Required: true
	Annotations LabelSet `json:"annotations"`

	// ends at
	// Required: true
	// Format: date-time
	EndsAt *strfmt.DateTime `json:"endsAt"`

	// fingerprint
	// Required: true
	Fingerprint *string `json:"fingerprint"`

	// receivers
	// Required: true
	Receivers []*Receiver `json:"receivers"`

	// starts at
	// Required: true
	// Format: date-time
	StartsAt *strfmt.DateTime `json:"startsAt"`

	// status
	// Required: true
	Status *AlertStatus `json:"status"`

	// updated at
	// Required: true
	// Format: date-time
	UpdatedAt *strfmt.DateTime `json:"updatedAt"`

	Alert
}

// Alert alert
//
// swagger:model alert
type Alert struct {

	// generator URL
	// Format: uri
	GeneratorURL strfmt.URI `json:"generatorURL,omitempty"`

	// labels
	// Required: true
	Labels LabelSet `json:"labels"`
}

type AlertStatus struct {

	// inhibited by
	// Required: true
	InhibitedBy []string `json:"inhibitedBy"`

	// silenced by
	// Required: true
	SilencedBy []string `json:"silencedBy"`

	// state
	// Required: true
	// Enum: [unprocessed active suppressed]
	State *string `json:"state"`
}

// Receiver receiver
//
// swagger:model receiver
type Receiver struct {

	// name
	// Required: true
	Name *string `json:"name"`
}

type LabelSet map[string]string

// PostableAlert : corresponds to the data AlertManager API
// needs to trigger alerts
type PostableAlert struct {
	StartsAt     *time.Time         `json:"startsAt,omitempty"`
	EndsAt       *time.Time         `json:"endsAt,omitempty"`
	Annotations  *map[string]string `json:"annotations,omitempty"`
	Labels       map[string]string  `json:"labels"`
	GeneratorURL *string            `json:"generatorURL,omitempty"`
}

// WithCondition In our basic model each receiver is uniquely
// identified by its name, which in AlertManager can be routed
// to by the label `alertname`.
func (p *PostableAlert) WithCondition(conditionId string) {
	if p.Labels == nil {
		p.Labels = make(map[string]string)
	}
	p.Labels["alertname"] = conditionId[:4]
}

// WithAnnotations adds the runtime information to the alert.
func (p *PostableAlert) WithAnnotations(key, value string) {
	if p.Annotations == nil {
		newMap := map[string]string{}
		p.Annotations = &newMap
	}
	(*p.Annotations)[key] = value
}

func (p *PostableAlert) WithLabels(key, value string) {
	if p.Labels == nil {
		p.Labels = make(map[string]string)
	}
	p.Labels[key] = value
}

func (p *PostableAlert) Must() error {
	if p.Labels == nil {
		return fmt.Errorf("missing PostableAlert.Labels")
	}
	if v, ok := p.Labels["alertname"]; !ok || v == "" {
		return fmt.Errorf(`missing PostableAlert.Labels["alertname"]`)
	}
	return nil
}

type Matcher struct {
	Name    string `json:"name"`
	Value   string `json:"value"`
	IsRegex bool   `json:"isRegex"`
	IsEqual *bool  `json:"isEqual,omitempty"`
}

// PostableSilence struct for PostableSilence
type PostableSilence struct {
	Id        *string   `json:"id,omitempty"`
	Matchers  []Matcher `json:"matchers"`
	StartsAt  time.Time `json:"startsAt"`
	EndsAt    time.Time `json:"endsAt"`
	CreatedBy string    `json:"createdBy"`
	Comment   string    `json:"comment"`
}

type PostSilencesResponse struct {
	SilenceID *string `json:"silenceID,omitempty"`
}

func (p *PostSilencesResponse) GetSilenceId() string {
	if p == nil || p.SilenceID == nil {
		return ""
	}
	return *p.SilenceID
}

// WithCondition In our basic model each receiver is uniquely
// identified by its name, which in AlertManager can be routed
// to by the label `alertname`.
func (p *PostableSilence) WithCondition(conditionId string) {
	if p.Matchers == nil {
		p.Matchers = make([]Matcher, 0)
	}
	p.Matchers = append(p.Matchers, Matcher{Name: "conditionId", Value: conditionId})
}

func (p *PostableSilence) WithDuration(dur time.Duration) {
	start := time.Now()
	end := start.Add(dur)
	p.StartsAt = start
	p.EndsAt = end
}

func (p *PostableSilence) WithSilenceId(silenceId string) {
	p.Id = &silenceId
}

func (p *PostableSilence) Must() error {
	if p.Matchers == nil {
		return fmt.Errorf("missing PostableSilence.Matchers")
	}
	if len(p.Matchers) == 0 {
		return fmt.Errorf("missing PostableSilence.Matchers")
	}
	if p.StartsAt.IsZero() {
		return fmt.Errorf("missing PostableSilence.StartsAt")
	}
	if p.EndsAt.IsZero() {
		return fmt.Errorf("missing PostableSilence.EndsAt")
	}
	return nil
}
