// @generated by protoc-gen-es v1.3.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file github.com/rancher/opni/plugins/metrics/apis/node/config.proto (package node.metrics.config, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, FieldMask, Message, proto3 } from "@bufbuild/protobuf";
import { Reference, Revision } from "../../../../pkg/apis/core/v1/core_pb";
import { RulesSpec } from "../../../../pkg/config/v1beta1/agent_config_pb";
import { Target } from "../../../../pkg/plugins/driverutil/types_pb";

/**
 * @generated from enum node.metrics.config.ConfigStatus
 */
export enum ConfigStatus {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: UpToDate = 1;
   */
  UpToDate = 1,

  /**
   * @generated from enum value: NeedsUpdate = 2;
   */
  NeedsUpdate = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigStatus)
proto3.util.setEnumType(ConfigStatus, "node.metrics.config.ConfigStatus", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "UpToDate" },
  { no: 2, name: "NeedsUpdate" },
]);

/**
 * This message is strictly an implementation detail and used for sync request/response only.
 * It is NOT persisted to the key-value store.
 *
 * @generated from message node.metrics.config.MetricsCapabilityStatus
 */
export class MetricsCapabilityStatus extends Message<MetricsCapabilityStatus> {
  /**
   * Note: this field is not used as part of an installable config type. It is
   * older and kept for compatibility purposes.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * If enabled is false, conditions may contain a list of relevant status
   * messages describing why the capability is disabled.
   *
   * @generated from field: repeated string conditions = 2;
   */
  conditions: string[] = [];

  /**
   * @generated from field: node.metrics.config.MetricsCapabilityConfig spec = 3;
   */
  spec?: MetricsCapabilityConfig;

  constructor(data?: PartialMessage<MetricsCapabilityStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.MetricsCapabilityStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "conditions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "spec", kind: "message", T: MetricsCapabilityConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsCapabilityStatus {
    return new MetricsCapabilityStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsCapabilityStatus {
    return new MetricsCapabilityStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsCapabilityStatus {
    return new MetricsCapabilityStatus().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsCapabilityStatus | PlainMessage<MetricsCapabilityStatus> | undefined, b: MetricsCapabilityStatus | PlainMessage<MetricsCapabilityStatus> | undefined): boolean {
    return proto3.util.equals(MetricsCapabilityStatus, a, b);
  }
}

/**
 * This message is the persisted configuration for a single node, or the
 * default configuration for all nodes.
 *
 * @generated from message node.metrics.config.MetricsCapabilityConfig
 */
export class MetricsCapabilityConfig extends Message<MetricsCapabilityConfig> {
  /**
   * @generated from field: core.Revision revision = 5;
   */
  revision?: Revision;

  /**
   * @generated from field: config.v1beta1.RulesSpec rules = 1;
   */
  rules?: RulesSpec;

  /**
   * @generated from field: optional node.metrics.config.MetricsCapabilityConfig.Driver driver = 4;
   */
  driver?: MetricsCapabilityConfig_Driver;

  /**
   * @generated from field: node.metrics.config.PrometheusSpec prometheus = 2;
   */
  prometheus?: PrometheusSpec;

  /**
   * @generated from field: node.metrics.config.OTELSpec otel = 3;
   */
  otel?: OTELSpec;

  constructor(data?: PartialMessage<MetricsCapabilityConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.MetricsCapabilityConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "revision", kind: "message", T: Revision },
    { no: 1, name: "rules", kind: "message", T: RulesSpec },
    { no: 4, name: "driver", kind: "enum", T: proto3.getEnumType(MetricsCapabilityConfig_Driver), opt: true },
    { no: 2, name: "prometheus", kind: "message", T: PrometheusSpec },
    { no: 3, name: "otel", kind: "message", T: OTELSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsCapabilityConfig {
    return new MetricsCapabilityConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsCapabilityConfig {
    return new MetricsCapabilityConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsCapabilityConfig {
    return new MetricsCapabilityConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsCapabilityConfig | PlainMessage<MetricsCapabilityConfig> | undefined, b: MetricsCapabilityConfig | PlainMessage<MetricsCapabilityConfig> | undefined): boolean {
    return proto3.util.equals(MetricsCapabilityConfig, a, b);
  }
}

/**
 * @generated from enum node.metrics.config.MetricsCapabilityConfig.Driver
 */
export enum MetricsCapabilityConfig_Driver {
  /**
   * @generated from enum value: None = 0;
   */
  None = 0,

  /**
   * @generated from enum value: Prometheus = 1;
   */
  Prometheus = 1,

  /**
   * @generated from enum value: OpenTelemetry = 2;
   */
  OpenTelemetry = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricsCapabilityConfig_Driver)
proto3.util.setEnumType(MetricsCapabilityConfig_Driver, "node.metrics.config.MetricsCapabilityConfig.Driver", [
  { no: 0, name: "None" },
  { no: 1, name: "Prometheus" },
  { no: 2, name: "OpenTelemetry" },
]);

/**
 * @generated from message node.metrics.config.PrometheusSpec
 */
export class PrometheusSpec extends Message<PrometheusSpec> {
  /**
   * @generated from field: optional string image = 1;
   */
  image?: string;

  constructor(data?: PartialMessage<PrometheusSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.PrometheusSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrometheusSpec {
    return new PrometheusSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrometheusSpec {
    return new PrometheusSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrometheusSpec {
    return new PrometheusSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PrometheusSpec | PlainMessage<PrometheusSpec> | undefined, b: PrometheusSpec | PlainMessage<PrometheusSpec> | undefined): boolean {
    return proto3.util.equals(PrometheusSpec, a, b);
  }
}

/**
 * @generated from message node.metrics.config.ScrapeConfig
 */
export class ScrapeConfig extends Message<ScrapeConfig> {
  /**
   * @generated from field: optional string jobName = 1;
   */
  jobName?: string;

  /**
   * @generated from field: repeated string targets = 2;
   */
  targets: string[] = [];

  /**
   * @generated from field: optional string scrapeInterval = 3;
   */
  scrapeInterval?: string;

  constructor(data?: PartialMessage<ScrapeConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.ScrapeConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jobName", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "targets", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "scrapeInterval", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrapeConfig {
    return new ScrapeConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrapeConfig {
    return new ScrapeConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrapeConfig {
    return new ScrapeConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ScrapeConfig | PlainMessage<ScrapeConfig> | undefined, b: ScrapeConfig | PlainMessage<ScrapeConfig> | undefined): boolean {
    return proto3.util.equals(ScrapeConfig, a, b);
  }
}

/**
 * @generated from message node.metrics.config.OTELSpec
 */
export class OTELSpec extends Message<OTELSpec> {
  /**
   * @generated from field: repeated node.metrics.config.ScrapeConfig additionalScrapeConfigs = 1;
   */
  additionalScrapeConfigs: ScrapeConfig[] = [];

  /**
   * @generated from field: node.metrics.config.WALConfig wal = 2;
   */
  wal?: WALConfig;

  /**
   * @generated from field: optional bool hostMetrics = 3;
   */
  hostMetrics?: boolean;

  constructor(data?: PartialMessage<OTELSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.OTELSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additionalScrapeConfigs", kind: "message", T: ScrapeConfig, repeated: true },
    { no: 2, name: "wal", kind: "message", T: WALConfig },
    { no: 3, name: "hostMetrics", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OTELSpec {
    return new OTELSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OTELSpec {
    return new OTELSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OTELSpec {
    return new OTELSpec().fromJsonString(jsonString, options);
  }

  static equals(a: OTELSpec | PlainMessage<OTELSpec> | undefined, b: OTELSpec | PlainMessage<OTELSpec> | undefined): boolean {
    return proto3.util.equals(OTELSpec, a, b);
  }
}

/**
 * @generated from message node.metrics.config.WALConfig
 */
export class WALConfig extends Message<WALConfig> {
  /**
   * @generated from field: optional bool enabled = 1;
   */
  enabled?: boolean;

  /**
   * @generated from field: optional int64 bufferSize = 2;
   */
  bufferSize?: bigint;

  /**
   * @generated from field: google.protobuf.Duration truncateFrequency = 3;
   */
  truncateFrequency?: Duration;

  constructor(data?: PartialMessage<WALConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.WALConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "bufferSize", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 3, name: "truncateFrequency", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WALConfig {
    return new WALConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WALConfig {
    return new WALConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WALConfig {
    return new WALConfig().fromJsonString(jsonString, options);
  }

  static equals(a: WALConfig | PlainMessage<WALConfig> | undefined, b: WALConfig | PlainMessage<WALConfig> | undefined): boolean {
    return proto3.util.equals(WALConfig, a, b);
  }
}

/**
 * @generated from message node.metrics.config.ConfigurationHistoryResponse
 */
export class ConfigurationHistoryResponse extends Message<ConfigurationHistoryResponse> {
  /**
   * @generated from field: repeated node.metrics.config.MetricsCapabilityConfig entries = 1;
   */
  entries: MetricsCapabilityConfig[] = [];

  constructor(data?: PartialMessage<ConfigurationHistoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.ConfigurationHistoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: MetricsCapabilityConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigurationHistoryResponse {
    return new ConfigurationHistoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigurationHistoryResponse {
    return new ConfigurationHistoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigurationHistoryResponse {
    return new ConfigurationHistoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigurationHistoryResponse | PlainMessage<ConfigurationHistoryResponse> | undefined, b: ConfigurationHistoryResponse | PlainMessage<ConfigurationHistoryResponse> | undefined): boolean {
    return proto3.util.equals(ConfigurationHistoryResponse, a, b);
  }
}

/**
 * @generated from message node.metrics.config.ResetRequest
 */
export class ResetRequest extends Message<ResetRequest> {
  /**
   * Only used for active config requests
   *
   * @generated from field: core.Reference node = 1;
   */
  node?: Reference;

  /**
   * @generated from field: google.protobuf.FieldMask mask = 2;
   */
  mask?: FieldMask;

  /**
   * @generated from field: node.metrics.config.MetricsCapabilityConfig patch = 3;
   */
  patch?: MetricsCapabilityConfig;

  constructor(data?: PartialMessage<ResetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.ResetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: Reference },
    { no: 2, name: "mask", kind: "message", T: FieldMask },
    { no: 3, name: "patch", kind: "message", T: MetricsCapabilityConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetRequest {
    return new ResetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetRequest {
    return new ResetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetRequest {
    return new ResetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResetRequest | PlainMessage<ResetRequest> | undefined, b: ResetRequest | PlainMessage<ResetRequest> | undefined): boolean {
    return proto3.util.equals(ResetRequest, a, b);
  }
}

/**
 * @generated from message node.metrics.config.GetRequest
 */
export class GetRequest extends Message<GetRequest> {
  /**
   * Only used for active config requests
   *
   * @generated from field: core.Reference node = 1;
   */
  node?: Reference;

  /**
   * @generated from field: core.Revision revision = 2;
   */
  revision?: Revision;

  constructor(data?: PartialMessage<GetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.GetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: Reference },
    { no: 2, name: "revision", kind: "message", T: Revision },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRequest {
    return new GetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRequest {
    return new GetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRequest {
    return new GetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRequest | PlainMessage<GetRequest> | undefined, b: GetRequest | PlainMessage<GetRequest> | undefined): boolean {
    return proto3.util.equals(GetRequest, a, b);
  }
}

/**
 * @generated from message node.metrics.config.SetRequest
 */
export class SetRequest extends Message<SetRequest> {
  /**
   * Only used for active config requests
   *
   * @generated from field: core.Reference node = 1;
   */
  node?: Reference;

  /**
   * @generated from field: node.metrics.config.MetricsCapabilityConfig spec = 2;
   */
  spec?: MetricsCapabilityConfig;

  constructor(data?: PartialMessage<SetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.SetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: Reference },
    { no: 2, name: "spec", kind: "message", T: MetricsCapabilityConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRequest {
    return new SetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRequest {
    return new SetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetRequest {
    return new SetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetRequest | PlainMessage<SetRequest> | undefined, b: SetRequest | PlainMessage<SetRequest> | undefined): boolean {
    return proto3.util.equals(SetRequest, a, b);
  }
}

/**
 * @generated from message node.metrics.config.ConfigurationHistoryRequest
 */
export class ConfigurationHistoryRequest extends Message<ConfigurationHistoryRequest> {
  /**
   * Only used for active config requests
   *
   * @generated from field: core.Reference node = 1;
   */
  node?: Reference;

  /**
   * @generated from field: driverutil.Target target = 2;
   */
  target = Target.ActiveConfiguration;

  /**
   * @generated from field: core.Revision revision = 3;
   */
  revision?: Revision;

  /**
   * @generated from field: bool includeValues = 4;
   */
  includeValues = false;

  constructor(data?: PartialMessage<ConfigurationHistoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.config.ConfigurationHistoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: Reference },
    { no: 2, name: "target", kind: "enum", T: proto3.getEnumType(Target) },
    { no: 3, name: "revision", kind: "message", T: Revision },
    { no: 4, name: "includeValues", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigurationHistoryRequest {
    return new ConfigurationHistoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigurationHistoryRequest {
    return new ConfigurationHistoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigurationHistoryRequest {
    return new ConfigurationHistoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigurationHistoryRequest | PlainMessage<ConfigurationHistoryRequest> | undefined, b: ConfigurationHistoryRequest | PlainMessage<ConfigurationHistoryRequest> | undefined): boolean {
    return proto3.util.equals(ConfigurationHistoryRequest, a, b);
  }
}

