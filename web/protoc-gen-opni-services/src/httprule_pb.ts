// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file example.proto (package docs, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message docs.User
 */
export class User extends Message<User> {
    /**
     * @generated from field: string first_name = 1;
     */
    firstName = "";

    /**
     * @generated from field: string last_name = 2;
     */
    lastName = "";

    /**
     * @generated from field: bool active = 3;
     */
    active = false;

    /**
     * @generated from field: docs.User manager = 4;
     */
    manager?: User;

    /**
     * @generated from field: repeated string locations = 5;
     */
    locations: string[] = [];

    /**
     * @generated from field: map<string, string> projects = 6;
     */
    projects: { [key: string]: string } = {};

    constructor(data?: PartialMessage<User>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = "docs.User";
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: "first_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
        { no: 4, name: "manager", kind: "message", T: User },
        { no: 5, name: "locations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 6, name: "projects", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "scalar", T: 9 /* ScalarType.STRING */ } },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User {
        return new User().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User {
        return new User().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User {
        return new User().fromJsonString(jsonString, options);
    }

    static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean {
        return proto3.util.equals(User, a, b);
    }
}

/**
 * @generated from message docs.HttpRule
 */
export class HttpRule extends Message<HttpRule> {
    /**
     * Selects a method to which this rule applies.
     *
     * Refer to [selector][google.api.DocumentationRule.selector] for syntax
     * details.
     *
     * @generated from field: string selector = 1;
     */
    selector = "";

    /**
     * Determines the URL pattern is matched by this rules. This pattern can be
     * used with any of the {get|put|post|delete|patch} methods. A custom method
     * can be defined using the 'custom' field.
     *
     * @generated from oneof docs.HttpRule.pattern
     */
    pattern: {
        /**
         * Maps to HTTP GET. Used for listing and getting information about
         * resources.
         *
         * @generated from field: string get = 2;
         */
        value: string;
        case: "get";
    } | {
        /**
         * Maps to HTTP PUT. Used for replacing a resource.
         *
         * @generated from field: string put = 3;
         */
        value: string;
        case: "put";
    } | {
        /**
         * Maps to HTTP POST. Used for creating a resource or performing an action.
         *
         * @generated from field: string post = 4;
         */
        value: string;
        case: "post";
    } | {
        /**
         * Maps to HTTP DELETE. Used for deleting a resource.
         *
         * @generated from field: string delete = 5;
         */
        value: string;
        case: "delete";
    } | {
        /**
         * Maps to HTTP PATCH. Used for updating a resource.
         *
         * @generated from field: string patch = 6;
         */
        value: string;
        case: "patch";
    } | {
        /**
         * The custom pattern is used for specifying an HTTP method that is not
         * included in the `pattern` field, such as HEAD, or "*" to leave the
         * HTTP method unspecified for this rule. The wild-card rule is useful
         * for services that provide content to Web (HTML) clients.
         *
         * @generated from field: docs.CustomHttpPattern custom = 8;
         */
        value: CustomHttpPattern;
        case: "custom";
    } | { case: undefined; value?: undefined } = { case: undefined };

    /**
     * The name of the request field whose value is mapped to the HTTP request
     * body, or `*` for mapping all request fields not captured by the path
     * pattern to the HTTP body, or omitted for not having any HTTP request body.
     *
     * NOTE: the referred field must be present at the top-level of the request
     * message type.
     *
     * @generated from field: string body = 7;
     */
    body = "";

    /**
     * Optional. The name of the response field whose value is mapped to the HTTP
     * response body. When omitted, the entire response message will be used
     * as the HTTP response body.
     *
     * NOTE: The referred field must be present at the top-level of the response
     * message type.
     *
     * @generated from field: string response_body = 12;
     */
    responseBody = "";

    /**
     * Additional HTTP bindings for the selector. Nested bindings must
     * not contain an `additional_bindings` field themselves (that is,
     * the nesting may only be one level deep).
     *
     * @generated from field: repeated docs.HttpRule additional_bindings = 11;
     */
    additionalBindings: HttpRule[] = [];

    constructor(data?: PartialMessage<HttpRule>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = "docs.HttpRule";
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: "selector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "get", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "pattern" },
        { no: 3, name: "put", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "pattern" },
        { no: 4, name: "post", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "pattern" },
        { no: 5, name: "delete", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "pattern" },
        { no: 6, name: "patch", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "pattern" },
        { no: 8, name: "custom", kind: "message", T: CustomHttpPattern, oneof: "pattern" },
        { no: 7, name: "body", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 12, name: "response_body", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 11, name: "additional_bindings", kind: "message", T: HttpRule, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpRule {
        return new HttpRule().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpRule {
        return new HttpRule().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpRule {
        return new HttpRule().fromJsonString(jsonString, options);
    }

    static equals(a: HttpRule | PlainMessage<HttpRule> | undefined, b: HttpRule | PlainMessage<HttpRule> | undefined): boolean {
        return proto3.util.equals(HttpRule, a, b);
    }
}

/**
 * A custom pattern is used for defining custom HTTP verb.
 *
 * @generated from message docs.CustomHttpPattern
 */
export class CustomHttpPattern extends Message<CustomHttpPattern> {
    /**
     * The name of this custom HTTP verb.
     *
     * @generated from field: string kind = 1;
     */
    kind = "";

    /**
     * The path matched by this custom verb.
     *
     * @generated from field: string path = 2;
     */
    path = "";

    constructor(data?: PartialMessage<CustomHttpPattern>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = "docs.CustomHttpPattern";
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomHttpPattern {
        return new CustomHttpPattern().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomHttpPattern {
        return new CustomHttpPattern().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomHttpPattern {
        return new CustomHttpPattern().fromJsonString(jsonString, options);
    }

    static equals(a: CustomHttpPattern | PlainMessage<CustomHttpPattern> | undefined, b: CustomHttpPattern | PlainMessage<CustomHttpPattern> | undefined): boolean {
        return proto3.util.equals(CustomHttpPattern, a, b);
    }
}