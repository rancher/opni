// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/plugins/example/pkg/example/example.proto

package example

import (
	context "context"
	errors "errors"
	cli "github.com/rancher/opni/internal/codegen/cli"
	v1 "github.com/rancher/opni/pkg/apis/core/v1"
	cliutil "github.com/rancher/opni/pkg/opni/cliutil"
	driverutil "github.com/rancher/opni/pkg/plugins/driverutil"
	storage "github.com/rancher/opni/pkg/storage"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	lo "github.com/samber/lo"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	errdetails "google.golang.org/genproto/googleapis/rpc/errdetails"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	strings "strings"
)

type contextKey_ExampleAPIExtension_type struct{}

var contextKey_ExampleAPIExtension contextKey_ExampleAPIExtension_type

func ContextWithExampleAPIExtensionClient(ctx context.Context, client ExampleAPIExtensionClient) context.Context {
	return context.WithValue(ctx, contextKey_ExampleAPIExtension, client)
}

func ExampleAPIExtensionClientFromContext(ctx context.Context) (ExampleAPIExtensionClient, bool) {
	client, ok := ctx.Value(contextKey_ExampleAPIExtension).(ExampleAPIExtensionClient)
	return client, ok
}

type contextKey_ExampleUnaryExtension_type struct{}

var contextKey_ExampleUnaryExtension contextKey_ExampleUnaryExtension_type

func ContextWithExampleUnaryExtensionClient(ctx context.Context, client ExampleUnaryExtensionClient) context.Context {
	return context.WithValue(ctx, contextKey_ExampleUnaryExtension, client)
}

func ExampleUnaryExtensionClientFromContext(ctx context.Context) (ExampleUnaryExtensionClient, bool) {
	client, ok := ctx.Value(contextKey_ExampleUnaryExtension).(ExampleUnaryExtensionClient)
	return client, ok
}

type contextKey_Config_type struct{}

var contextKey_Config contextKey_Config_type

func ContextWithConfigClient(ctx context.Context, client ConfigClient) context.Context {
	return context.WithValue(ctx, contextKey_Config, client)
}

func ConfigClientFromContext(ctx context.Context) (ConfigClient, bool) {
	client, ok := ctx.Value(contextKey_Config).(ConfigClient)
	return client, ok
}

var extraCmds_ExampleAPIExtension []*cobra.Command

func addExtraExampleAPIExtensionCmd(custom *cobra.Command) {
	extraCmds_ExampleAPIExtension = append(extraCmds_ExampleAPIExtension, custom)
}

func BuildExampleAPIExtensionCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "example-api-extension",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd, append([]*cobra.Command{
		BuildExampleAPIExtensionEchoCmd(),
		BuildExampleAPIExtensionReadyCmd(),
	}, extraCmds_ExampleAPIExtension...)...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildExampleAPIExtensionEchoCmd() *cobra.Command {
	in := &EchoRequest{}
	cmd := &cobra.Command{
		Use:   "echo",
		Short: "",
		Long: `
HTTP handlers for this method:
- POST /echo
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExampleAPIExtensionClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.Echo(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildExampleAPIExtensionReadyCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ready",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExampleAPIExtensionClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.Ready(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

var extraCmds_ExampleUnaryExtension []*cobra.Command

func addExtraExampleUnaryExtensionCmd(custom *cobra.Command) {
	extraCmds_ExampleUnaryExtension = append(extraCmds_ExampleUnaryExtension, custom)
}

func BuildExampleUnaryExtensionCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "example-unary-extension",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cmd.AddCommand(BuildExampleUnaryExtensionHelloCmd())
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildExampleUnaryExtensionHelloCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "hello",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ExampleUnaryExtensionClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.Hello(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

var extraCmds_Config []*cobra.Command

func addExtraConfigCmd(custom *cobra.Command) {
	extraCmds_Config = append(extraCmds_Config, custom)
}

func BuildConfigCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "config",
		Short:             ``,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cliutil.AddSubcommands(cmd, append([]*cobra.Command{
		BuildConfigGetDefaultConfigurationCmd(),
		BuildConfigSetDefaultConfigurationCmd(),
		BuildConfigGetConfigurationCmd(),
		BuildConfigSetConfigurationCmd(),
		BuildConfigResetDefaultConfigurationCmd(),
		BuildConfigResetConfigurationCmd(),
		BuildConfigConfigurationHistoryCmd(),
	}, extraCmds_Config...)...)
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildConfigGetDefaultConfigurationCmd() *cobra.Command {
	in := &driverutil.GetRequest{}
	cmd := &cobra.Command{
		Use:               "get-default",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.GetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildConfigSetDefaultConfigurationCmd() *cobra.Command {
	in := &SetRequest{}
	cmd := &cobra.Command{
		Use:               "set-default",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if curValue, err := client.GetDefaultConfiguration(cmd.Context(), &driverutil.GetRequest{}); err == nil {
					in.Spec = curValue
				}
				if edited, err := cliutil.EditInteractive(in.Spec); err != nil {
					return err
				} else {
					in.Spec = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if err := cliutil.LoadFromFile(in, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.SetDefaultConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildConfigGetConfigurationCmd() *cobra.Command {
	in := &driverutil.GetRequest{}
	cmd := &cobra.Command{
		Use:               "get",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.GetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	return cmd
}

func BuildConfigSetConfigurationCmd() *cobra.Command {
	in := &SetRequest{}
	cmd := &cobra.Command{
		Use:               "set",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if curValue, err := client.GetConfiguration(cmd.Context(), &driverutil.GetRequest{}); err == nil {
					in.Spec = curValue
				}
				if edited, err := cliutil.EditInteractive(in.Spec); err != nil {
					return err
				} else {
					in.Spec = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if err := cliutil.LoadFromFile(in, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.SetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildConfigResetDefaultConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "reset-default",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.ResetDefaultConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func BuildConfigResetConfigurationCmd() *cobra.Command {
	in := &ResetRequest{}
	cmd := &cobra.Command{
		Use:               "reset",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if cmd.Flags().Lookup("interactive").Value.String() == "true" {
				if edited, err := cliutil.EditInteractive(in); err != nil {
					return err
				} else {
					in = edited
				}
			} else if fileName := cmd.Flags().Lookup("file").Value.String(); fileName != "" {
				if err := cliutil.LoadFromFile(in, fileName); err != nil {
					return err
				}
			}
			if in == nil {
				return errors.New("no input provided")
			}
			_, err := client.ResetConfiguration(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringP("file", "f", "", "path to a file containing the config, or - to read from stdin")
	cmd.Flags().BoolP("interactive", "i", false, "edit the config interactively in an editor")
	cmd.MarkFlagsMutuallyExclusive("file", "interactive")
	cmd.MarkFlagFilename("file")
	return cmd
}

func BuildConfigConfigurationHistoryCmd() *cobra.Command {
	in := &driverutil.ConfigurationHistoryRequest{}
	cmd := &cobra.Command{
		Use:               "history",
		Short:             "",
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := ConfigClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			if in == nil {
				return errors.New("no input provided")
			}
			response, err := client.ConfigurationHistory(cmd.Context(), in)
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.RegisterFlagCompletionFunc("target", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"ActiveConfiguration", "DefaultConfiguration"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func (in *EchoRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("EchoRequest", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Message, strings.Join(append(prefix, "message"), "."), "", "")
	return fs
}

func (in *SetRequest) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SetRequest", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Spec == nil {
		in.Spec = &ConfigSpec{}
	}
	fs.AddFlagSet(in.Spec.FlagSet(append(prefix, "spec")...))
	return fs
}

func (in *SetRequest) RedactSecrets() {
	if in == nil {
		return
	}
	in.Spec.RedactSecrets()
}

func (in *SetRequest) UnredactSecrets(unredacted *SetRequest) error {
	if in == nil {
		return nil
	}
	var details []protoiface.MessageV1
	if err := in.Spec.UnredactSecrets(unredacted.GetSpec()); storage.IsDiscontinuity(err) {
		for _, sd := range status.Convert(err).Details() {
			if info, ok := sd.(*errdetails.ErrorInfo); ok {
				info.Metadata["field"] = "spec." + info.Metadata["field"]
				details = append(details, info)
			}
		}
	}
	if len(details) == 0 {
		return nil
	}
	return lo.Must(status.New(codes.InvalidArgument, "cannot unredact: missing values for secret fields").WithDetails(details...)).Err()
}

func (in *ConfigSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("ConfigSpec", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Revision == nil {
		in.Revision = &v1.Revision{}
	}
	fs.AddFlagSet(in.Revision.FlagSet(append(prefix, "revision")...))
	fs.Var(flagutil.StringPtrValue(nil, &in.StringVar), strings.Join(append(prefix, "string-var"), "."), "")
	fs.Var(flagutil.IntPtrValue(nil, &in.IntVar), strings.Join(append(prefix, "int-var"), "."), "")
	fs.Var(flagutil.BoolPtrValue(nil, &in.BoolVar), strings.Join(append(prefix, "bool-var"), "."), "")
	if in.MessageVar == nil {
		in.MessageVar = &Message{}
	}
	fs.AddFlagSet(in.MessageVar.FlagSet(append(prefix, "message-var")...))
	fs.Var(flagutil.StringPtrValue(nil, &in.SecretVar), strings.Join(append(prefix, "secret-var"), "."), "\x1b[31m[secret]\x1b[0m ")
	return fs
}

func (in *ConfigSpec) RedactSecrets() {
	if in == nil {
		return
	}
	if in.GetSecretVar() != "" {
		in.SecretVar = flagutil.Ptr("***")
	}
}

func (in *ConfigSpec) UnredactSecrets(unredacted *ConfigSpec) error {
	if in == nil {
		return nil
	}
	var details []protoiface.MessageV1
	if in.GetSecretVar() == "***" {
		if unredacted.GetSecretVar() == "" {
			details = append(details, &errdetails.ErrorInfo{
				Reason:   "DISCONTINUITY",
				Metadata: map[string]string{"field": "secretVar"},
			})
		} else {
			*in.SecretVar = *unredacted.SecretVar
		}
	}
	if len(details) == 0 {
		return nil
	}
	return lo.Must(status.New(codes.InvalidArgument, "cannot unredact: missing values for secret fields").WithDetails(details...)).Err()
}

func (in *Message) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("Message", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringSliceVar(&in.StringSliceVar, strings.Join(append(prefix, "string-slice-var"), "."), nil, "")
	fs.StringToStringVar(&in.StringMapVar, strings.Join(append(prefix, "string-map-var"), "."), nil, "")
	return fs
}
