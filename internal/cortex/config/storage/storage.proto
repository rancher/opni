// Code generated by internal/codegen. You may edit parts of this file.
// Field numbers and custom options will be preserved for matching field names.
// All other modifications will be lost.
syntax = "proto3";
package storage;

import "github.com/rancher/opni/internal/codegen/cli/cli.proto";
import "github.com/rancher/opni/pkg/validation/validate.proto";
import "google/protobuf/duration.proto";

option go_package      = "github.com/rancher/opni/internal/cortex/config/storage";
option (cli.generator) = {
  generate:          true
  generate_deepcopy: true
};

message Config {
  // Backend storage to use. Supported backends are: s3, gcs, azure, swift, filesystem.
  optional string backend = 1 [
    (buf.validate.field) = {
      cel: [
        {
          id:         "backend"
          message:    "invalid backend"
          expression: "this in ['s3', 'gcs', 'azure', 'swift', 'filesystem']"
        }
      ]
    },
    (cli.flag) = {
      default: "s3"
    }
  ];
  S3Config         s3         = 2;
  GcsConfig        gcs        = 3;
  AzureConfig      azure      = 4;
  SwiftConfig      swift      = 5;
  FilesystemConfig filesystem = 6;
}

message AzureConfig {
  option (buf.validate.message) = {
    cel: [
      {
        id:         "require_msi_or_account_key"
        message:    "either msi_resource or account_key must be set"
        expression: "has(this.msi_resource) != has(this.account_key)"
      },
      {
        id:         "no_user_id_with_account_key"
        message:    "user_assigned_id cannot be set when using account_key authentication"
        expression: "has(this.account_key) ? !has(this.user_assigned_id) : true"
      }
    ]
  };
  // Azure storage account name
  optional string account_name = 1 [(buf.validate.field) = {required: true}];
  // Azure storage account key
  optional string account_key = 2 [(cli.flag) = {secret: true}];
  // Azure storage container name
  optional string container_name = 3 [(buf.validate.field) = {required: true}];
  // Azure storage endpoint suffix without schema. The account name will be prefixed to this value to create the FQDN
  optional string endpoint_suffix = 4;
  // Number of retries for recoverable errors
  optional int32 max_retries = 5 [
    (buf.validate.field) = {
      int32: {
        gt: 0
      }
    },
    (cli.flag) = {
      default: "20"
    }
  ];
  // Azure storage MSI resource. Either this or account key must be set.
  optional string msi_resource = 6 [(cli.flag) = {secret: true}];
  // Azure storage MSI resource managed identity client Id. If not supplied system assigned identity is used
  optional string user_assigned_id = 7;
  HttpConfig      http             = 8;
}

message FilesystemConfig {}

message GcsConfig {
  // GCS bucket name
  optional string bucket_name = 1 [(buf.validate.field) = {required: true}];
  // JSON representing either a Google Developers Console client_credentials.json file or a Google Developers service account key file. If empty, fallback to Google default logic.
  optional string service_account = 2 [
    (buf.validate.field) = {
      required: true
    },
    (cli.flag) = {
      secret: true
    }
  ];
}

message HttpConfig {
  // The time an idle connection will remain idle before closing.
  google.protobuf.Duration idle_conn_timeout = 1 [(cli.flag) = {default: "1m30s"}];
  // The amount of time the client will wait for a servers response headers.
  google.protobuf.Duration response_header_timeout = 2 [(cli.flag) = {default: "2m0s"}];
  // If the client connects via HTTPS and this option is enabled, the client will accept any certificate and hostname.
  optional bool insecure_skip_verify = 3 [(cli.flag) = {default: "false"}];
  // Maximum time to wait for a TLS handshake. 0 means no limit.
  google.protobuf.Duration tls_handshake_timeout = 4 [(cli.flag) = {default: "10s"}];
  // The time to wait for a server's first response headers after fully writing the request headers if the request has an Expect header. 0 to send the request body immediately.
  google.protobuf.Duration expect_continue_timeout = 5 [(cli.flag) = {default: "1s"}];
  // Maximum number of idle (keep-alive) connections across all hosts. 0 means no limit.
  optional int32 max_idle_connections = 6 [(cli.flag) = {default: "100"}];
  // Maximum number of idle (keep-alive) connections to keep per-host. If 0, a built-in default value is used.
  optional int32 max_idle_connections_per_host = 7 [(cli.flag) = {default: "100"}];
  // Maximum number of connections per host. 0 means no limit.
  optional int32 max_connections_per_host = 8 [(cli.flag) = {default: "0"}];
}

message S3Config {
  // The S3 bucket endpoint. It could be an AWS S3 endpoint listed at https://docs.aws.amazon.com/general/latest/gr/s3.html or the address of an S3-compatible service in hostname:port format.
  optional string endpoint = 1 [
    (buf.validate.field) = {
      string: {
        uri: true
      }
      required: true
    }
  ];
  // S3 region. If unset, the client will issue a S3 GetBucketLocation API call to autodetect it.
  optional string region = 2;
  // S3 bucket name
  optional string bucket_name = 3 [(buf.validate.field) = {required: true}];
  // S3 secret access key
  optional string secret_access_key = 4 [
    (buf.validate.field) = {
      required: true
    },
    (cli.flag) = {
      secret: true
    }
  ];
  // S3 access key ID
  optional string access_key_id = 5 [(buf.validate.field) = {required: true}];
  // If enabled, use http:// for the S3 endpoint instead of https://. This could be useful in local dev/test environments while using an S3-compatible backend storage, like Minio.
  optional bool insecure = 6 [(cli.flag) = {default: "false"}];
  // The signature version to use for authenticating against S3. Supported values are: v4, v2.
  optional string signature_version = 7 [(cli.flag) = {default: "v4"}];
  // The s3 bucket lookup style. Supported values are: auto, virtual-hosted, path.
  optional string bucket_lookup_type = 8  [(cli.flag) = {default: "auto"}];
  S3SSEConfig     sse                = 9;
  HttpConfig      http               = 10;
}

message S3SSEConfig {
  // Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3.
  optional string type = 1 [
    (buf.validate.field) = {
      string: {
        in: [
          "SSE-KMS",
          "SSE-S3"
        ]
      }
    }
  ];
  // KMS Key ID used to encrypt objects in S3
  optional string kms_key_id = 2;
  // KMS Encryption Context used for object encryption. It expects JSON formatted string.
  optional string kms_encryption_context = 3 [(cli.flag) = {secret: true}];
}

message SwiftConfig {
  option (buf.validate.message) = {
    cel: [
      {
        id:         "username_xor_credentials_auth"
        message:    "username/user_id are mutually exclusive with application_credential_name/application_credential_id"
        expression: "(has(this.username) || has(this.user_id)) && (has(this.application_credential_name) || has(this.application_credential_id))"
      },
      {
        id:         "require_any_credentials"
        message:    "one of {username|user_id|application_credential_name|application_credential_id} is required"
        expression: "has(this.username) || has(this.user_id) || has(this.application_credential_name) || has(this.application_credential_id)"
      },
      {
        id:         "require_password"
        message:    "password is required when username or user_id is set"
        expression: "(has(this.username) || has(this.user_id)) ? has(this.password) : true"
      },
      {
        id:         "require_application_credential_secret"
        message:    "application_credential_secret is required when application_credential_id or application_credential_name is set"
        expression: "(has(this.application_credential_name) || has(this.application_credential_id)) ? has(this.application_credential_secret) : true"
      },
      {
        id:         "autodetect_auth_version_url"
        message:    "when auth_version is set to 0 (autodetect) auth_url must end with /v2.X or /v3"
        expression: "this.auth_version == 0 ? (this.auth_url.matches('.*/v2\\.[0-9]$') || this.auth_url.endsWith('/v3')) : true"
      },
      {
        id:         "explicit_auth_version_url"
        message:    "when auth_version is not 0 (autodetect) auth_url must not end with a version"
        expression: "this.auth_version != 0 ? (!this.auth_url.matches('.*/v[0-9\\.]+$')) : true"
      }
    ]
  };
  // OpenStack Swift authentication API version. 0 to autodetect.
  optional int32 auth_version = 1 [(cli.flag) = {default: "0"}];
  // OpenStack Swift authentication URL
  optional string auth_url = 2 [
    (buf.validate.field) = {
      string: {
        uri: true
      }
      required: true
    }
  ];
  // OpenStack Swift username.
  optional string username = 3;
  // OpenStack Swift user's domain name.
  optional string user_domain_name = 4;
  // OpenStack Swift user's domain ID.
  optional string user_domain_id = 5;
  // OpenStack Swift user ID.
  optional string user_id = 6;
  // OpenStack Swift API key.
  optional string password = 7 [(cli.flag) = {secret: true}];
  // OpenStack Swift user's domain ID.
  optional string domain_id = 8;
  // OpenStack Swift user's domain name.
  optional string domain_name = 9;
  // OpenStack Swift application credential ID.
  optional string application_credential_id = 10;
  // OpenStack Swift application credential name.
  optional string application_credential_name = 11;
  // OpenStack Swift application credential secret.
  optional string application_credential_secret = 12 [(cli.flag) = {secret: true}];
  // OpenStack Swift project ID (v2,v3 auth only).
  optional string project_id = 13;
  // OpenStack Swift project name (v2,v3 auth only).
  optional string project_name = 14;
  // ID of the OpenStack Swift project's domain (v3 auth only), only needed if it differs the from user domain.
  optional string project_domain_id = 15;
  // Name of the OpenStack Swift project's domain (v3 auth only), only needed if it differs from the user domain.
  optional string project_domain_name = 16;
  // OpenStack Swift Region to use (v2,v3 auth only).
  optional string region_name = 17;
  // Name of the OpenStack Swift container to put chunks in.
  optional string container_name = 18;
  // Max retries on requests error.
  optional int32 max_retries = 19 [(cli.flag) = {default: "3"}];
  // Time after which a connection attempt is aborted.
  google.protobuf.Duration connect_timeout = 20 [(cli.flag) = {default: "10s"}];
  // Time after which an idle request is aborted. The timeout watchdog is reset each time some data is received, so the timeout triggers after X time no data is received on a request.
  google.protobuf.Duration request_timeout = 21 [(cli.flag) = {default: "5s"}];
}
