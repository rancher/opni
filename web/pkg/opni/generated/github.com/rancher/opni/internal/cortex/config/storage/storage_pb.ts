// Code generated by internal/codegen. DO NOT EDIT.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file github.com/rancher/opni/internal/cortex/config/storage/storage.proto (package storage, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message storage.Config
 */
export class Config extends Message<Config> {
  /**
   * Backend storage to use. Supported backends are: s3, gcs, azure, swift, filesystem.
   *
   * @generated from field: optional string backend = 1;
   */
  backend?: string;

  /**
   * @generated from field: storage.S3Config s3 = 2;
   */
  s3?: S3Config;

  /**
   * @generated from field: storage.GcsConfig gcs = 3;
   */
  gcs?: GcsConfig;

  /**
   * @generated from field: storage.AzureConfig azure = 4;
   */
  azure?: AzureConfig;

  /**
   * @generated from field: storage.SwiftConfig swift = 5;
   */
  swift?: SwiftConfig;

  /**
   * @generated from field: storage.FilesystemConfig filesystem = 6;
   */
  filesystem?: FilesystemConfig;

  constructor(data?: PartialMessage<Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backend", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "s3", kind: "message", T: S3Config },
    { no: 3, name: "gcs", kind: "message", T: GcsConfig },
    { no: 4, name: "azure", kind: "message", T: AzureConfig },
    { no: 5, name: "swift", kind: "message", T: SwiftConfig },
    { no: 6, name: "filesystem", kind: "message", T: FilesystemConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Config {
    return new Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Config {
    return new Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Config {
    return new Config().fromJsonString(jsonString, options);
  }

  static equals(a: Config | PlainMessage<Config> | undefined, b: Config | PlainMessage<Config> | undefined): boolean {
    return proto3.util.equals(Config, a, b);
  }
}

/**
 * @generated from message storage.AzureConfig
 */
export class AzureConfig extends Message<AzureConfig> {
  /**
   * Azure storage account name
   *
   * @generated from field: optional string account_name = 1;
   */
  accountName?: string;

  /**
   * Azure storage account key
   *
   * @generated from field: optional string account_key = 2;
   */
  accountKey?: string;

  /**
   * Azure storage container name
   *
   * @generated from field: optional string container_name = 3;
   */
  containerName?: string;

  /**
   * Azure storage endpoint suffix without schema. The account name will be prefixed to this value to create the FQDN
   *
   * @generated from field: optional string endpoint_suffix = 4;
   */
  endpointSuffix?: string;

  /**
   * Number of retries for recoverable errors
   *
   * @generated from field: optional int32 max_retries = 5;
   */
  maxRetries?: number;

  /**
   * Azure storage MSI resource. Either this or account key must be set.
   *
   * @generated from field: optional string msi_resource = 6;
   */
  msiResource?: string;

  /**
   * Azure storage MSI resource managed identity client Id. If not supplied system assigned identity is used
   *
   * @generated from field: optional string user_assigned_id = 7;
   */
  userAssignedId?: string;

  /**
   * @generated from field: storage.HttpConfig http = 8;
   */
  http?: HttpConfig;

  constructor(data?: PartialMessage<AzureConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.AzureConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "account_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "container_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "endpoint_suffix", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "max_retries", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "msi_resource", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "user_assigned_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "http", kind: "message", T: HttpConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureConfig {
    return new AzureConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureConfig {
    return new AzureConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureConfig {
    return new AzureConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AzureConfig | PlainMessage<AzureConfig> | undefined, b: AzureConfig | PlainMessage<AzureConfig> | undefined): boolean {
    return proto3.util.equals(AzureConfig, a, b);
  }
}

/**
 * @generated from message storage.FilesystemConfig
 */
export class FilesystemConfig extends Message<FilesystemConfig> {
  constructor(data?: PartialMessage<FilesystemConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.FilesystemConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilesystemConfig {
    return new FilesystemConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilesystemConfig {
    return new FilesystemConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilesystemConfig {
    return new FilesystemConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FilesystemConfig | PlainMessage<FilesystemConfig> | undefined, b: FilesystemConfig | PlainMessage<FilesystemConfig> | undefined): boolean {
    return proto3.util.equals(FilesystemConfig, a, b);
  }
}

/**
 * @generated from message storage.GcsConfig
 */
export class GcsConfig extends Message<GcsConfig> {
  /**
   * GCS bucket name
   *
   * @generated from field: optional string bucket_name = 1;
   */
  bucketName?: string;

  /**
   * JSON representing either a Google Developers Console client_credentials.json file or a Google Developers service account key file. If empty, fallback to Google default logic.
   *
   * @generated from field: optional string service_account = 2;
   */
  serviceAccount?: string;

  constructor(data?: PartialMessage<GcsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.GcsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "service_account", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GcsConfig {
    return new GcsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GcsConfig {
    return new GcsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GcsConfig {
    return new GcsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: GcsConfig | PlainMessage<GcsConfig> | undefined, b: GcsConfig | PlainMessage<GcsConfig> | undefined): boolean {
    return proto3.util.equals(GcsConfig, a, b);
  }
}

/**
 * @generated from message storage.HttpConfig
 */
export class HttpConfig extends Message<HttpConfig> {
  /**
   * The time an idle connection will remain idle before closing.
   *
   * @generated from field: google.protobuf.Duration idle_conn_timeout = 1;
   */
  idleConnTimeout?: Duration;

  /**
   * The amount of time the client will wait for a servers response headers.
   *
   * @generated from field: google.protobuf.Duration response_header_timeout = 2;
   */
  responseHeaderTimeout?: Duration;

  /**
   * If the client connects via HTTPS and this option is enabled, the client will accept any certificate and hostname.
   *
   * @generated from field: optional bool insecure_skip_verify = 3;
   */
  insecureSkipVerify?: boolean;

  /**
   * Maximum time to wait for a TLS handshake. 0 means no limit.
   *
   * @generated from field: google.protobuf.Duration tls_handshake_timeout = 4;
   */
  tlsHandshakeTimeout?: Duration;

  /**
   * The time to wait for a server's first response headers after fully writing the request headers if the request has an Expect header. 0 to send the request body immediately.
   *
   * @generated from field: google.protobuf.Duration expect_continue_timeout = 5;
   */
  expectContinueTimeout?: Duration;

  /**
   * Maximum number of idle (keep-alive) connections across all hosts. 0 means no limit.
   *
   * @generated from field: optional int32 max_idle_connections = 6;
   */
  maxIdleConnections?: number;

  /**
   * Maximum number of idle (keep-alive) connections to keep per-host. If 0, a built-in default value is used.
   *
   * @generated from field: optional int32 max_idle_connections_per_host = 7;
   */
  maxIdleConnectionsPerHost?: number;

  /**
   * Maximum number of connections per host. 0 means no limit.
   *
   * @generated from field: optional int32 max_connections_per_host = 8;
   */
  maxConnectionsPerHost?: number;

  constructor(data?: PartialMessage<HttpConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.HttpConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idle_conn_timeout", kind: "message", T: Duration },
    { no: 2, name: "response_header_timeout", kind: "message", T: Duration },
    { no: 3, name: "insecure_skip_verify", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "tls_handshake_timeout", kind: "message", T: Duration },
    { no: 5, name: "expect_continue_timeout", kind: "message", T: Duration },
    { no: 6, name: "max_idle_connections", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "max_idle_connections_per_host", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "max_connections_per_host", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpConfig {
    return new HttpConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpConfig {
    return new HttpConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpConfig {
    return new HttpConfig().fromJsonString(jsonString, options);
  }

  static equals(a: HttpConfig | PlainMessage<HttpConfig> | undefined, b: HttpConfig | PlainMessage<HttpConfig> | undefined): boolean {
    return proto3.util.equals(HttpConfig, a, b);
  }
}

/**
 * @generated from message storage.S3Config
 */
export class S3Config extends Message<S3Config> {
  /**
   * The S3 bucket endpoint. It could be an AWS S3 endpoint listed at https://docs.aws.amazon.com/general/latest/gr/s3.html or the address of an S3-compatible service in hostname:port format.
   *
   * @generated from field: optional string endpoint = 1;
   */
  endpoint?: string;

  /**
   * S3 region. If unset, the client will issue a S3 GetBucketLocation API call to autodetect it.
   *
   * @generated from field: optional string region = 2;
   */
  region?: string;

  /**
   * S3 bucket name
   *
   * @generated from field: optional string bucket_name = 3;
   */
  bucketName?: string;

  /**
   * S3 secret access key
   *
   * @generated from field: optional string secret_access_key = 4;
   */
  secretAccessKey?: string;

  /**
   * S3 access key ID
   *
   * @generated from field: optional string access_key_id = 5;
   */
  accessKeyId?: string;

  /**
   * If enabled, use http:// for the S3 endpoint instead of https://. This could be useful in local dev/test environments while using an S3-compatible backend storage, like Minio.
   *
   * @generated from field: optional bool insecure = 6;
   */
  insecure?: boolean;

  /**
   * The signature version to use for authenticating against S3. Supported values are: v4, v2.
   *
   * @generated from field: optional string signature_version = 7;
   */
  signatureVersion?: string;

  /**
   * The s3 bucket lookup style. Supported values are: auto, virtual-hosted, path.
   *
   * @generated from field: optional string bucket_lookup_type = 8;
   */
  bucketLookupType?: string;

  /**
   * @generated from field: storage.S3SSEConfig sse = 9;
   */
  sse?: S3SSEConfig;

  /**
   * @generated from field: storage.HttpConfig http = 10;
   */
  http?: HttpConfig;

  constructor(data?: PartialMessage<S3Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.S3Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "bucket_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "secret_access_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "access_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "insecure", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "signature_version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "bucket_lookup_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "sse", kind: "message", T: S3SSEConfig },
    { no: 10, name: "http", kind: "message", T: HttpConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): S3Config {
    return new S3Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): S3Config {
    return new S3Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): S3Config {
    return new S3Config().fromJsonString(jsonString, options);
  }

  static equals(a: S3Config | PlainMessage<S3Config> | undefined, b: S3Config | PlainMessage<S3Config> | undefined): boolean {
    return proto3.util.equals(S3Config, a, b);
  }
}

/**
 * @generated from message storage.S3SSEConfig
 */
export class S3SSEConfig extends Message<S3SSEConfig> {
  /**
   * Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3.
   *
   * @generated from field: optional string type = 1;
   */
  type?: string;

  /**
   * KMS Key ID used to encrypt objects in S3
   *
   * @generated from field: optional string kms_key_id = 2;
   */
  kmsKeyId?: string;

  /**
   * KMS Encryption Context used for object encryption. It expects JSON formatted string.
   *
   * @generated from field: optional string kms_encryption_context = 3;
   */
  kmsEncryptionContext?: string;

  constructor(data?: PartialMessage<S3SSEConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.S3SSEConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "kms_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "kms_encryption_context", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): S3SSEConfig {
    return new S3SSEConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): S3SSEConfig {
    return new S3SSEConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): S3SSEConfig {
    return new S3SSEConfig().fromJsonString(jsonString, options);
  }

  static equals(a: S3SSEConfig | PlainMessage<S3SSEConfig> | undefined, b: S3SSEConfig | PlainMessage<S3SSEConfig> | undefined): boolean {
    return proto3.util.equals(S3SSEConfig, a, b);
  }
}

/**
 * @generated from message storage.SwiftConfig
 */
export class SwiftConfig extends Message<SwiftConfig> {
  /**
   * OpenStack Swift authentication API version. 0 to autodetect.
   *
   * @generated from field: optional int32 auth_version = 1;
   */
  authVersion?: number;

  /**
   * OpenStack Swift authentication URL
   *
   * @generated from field: optional string auth_url = 2;
   */
  authUrl?: string;

  /**
   * OpenStack Swift username.
   *
   * @generated from field: optional string username = 3;
   */
  username?: string;

  /**
   * OpenStack Swift user's domain name.
   *
   * @generated from field: optional string user_domain_name = 4;
   */
  userDomainName?: string;

  /**
   * OpenStack Swift user's domain ID.
   *
   * @generated from field: optional string user_domain_id = 5;
   */
  userDomainId?: string;

  /**
   * OpenStack Swift user ID.
   *
   * @generated from field: optional string user_id = 6;
   */
  userId?: string;

  /**
   * OpenStack Swift API key.
   *
   * @generated from field: optional string password = 7;
   */
  password?: string;

  /**
   * OpenStack Swift user's domain ID.
   *
   * @generated from field: optional string domain_id = 8;
   */
  domainId?: string;

  /**
   * OpenStack Swift user's domain name.
   *
   * @generated from field: optional string domain_name = 9;
   */
  domainName?: string;

  /**
   * OpenStack Swift application credential ID.
   *
   * @generated from field: optional string application_credential_id = 10;
   */
  applicationCredentialId?: string;

  /**
   * OpenStack Swift application credential name.
   *
   * @generated from field: optional string application_credential_name = 11;
   */
  applicationCredentialName?: string;

  /**
   * OpenStack Swift application credential secret.
   *
   * @generated from field: optional string application_credential_secret = 12;
   */
  applicationCredentialSecret?: string;

  /**
   * OpenStack Swift project ID (v2,v3 auth only).
   *
   * @generated from field: optional string project_id = 13;
   */
  projectId?: string;

  /**
   * OpenStack Swift project name (v2,v3 auth only).
   *
   * @generated from field: optional string project_name = 14;
   */
  projectName?: string;

  /**
   * ID of the OpenStack Swift project's domain (v3 auth only), only needed if it differs the from user domain.
   *
   * @generated from field: optional string project_domain_id = 15;
   */
  projectDomainId?: string;

  /**
   * Name of the OpenStack Swift project's domain (v3 auth only), only needed if it differs from the user domain.
   *
   * @generated from field: optional string project_domain_name = 16;
   */
  projectDomainName?: string;

  /**
   * OpenStack Swift Region to use (v2,v3 auth only).
   *
   * @generated from field: optional string region_name = 17;
   */
  regionName?: string;

  /**
   * Name of the OpenStack Swift container to put chunks in.
   *
   * @generated from field: optional string container_name = 18;
   */
  containerName?: string;

  /**
   * Max retries on requests error.
   *
   * @generated from field: optional int32 max_retries = 19;
   */
  maxRetries?: number;

  /**
   * Time after which a connection attempt is aborted.
   *
   * @generated from field: google.protobuf.Duration connect_timeout = 20;
   */
  connectTimeout?: Duration;

  /**
   * Time after which an idle request is aborted. The timeout watchdog is reset each time some data is received, so the timeout triggers after X time no data is received on a request.
   *
   * @generated from field: google.protobuf.Duration request_timeout = 21;
   */
  requestTimeout?: Duration;

  constructor(data?: PartialMessage<SwiftConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.SwiftConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auth_version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "auth_url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "user_domain_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "user_domain_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "domain_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "domain_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "application_credential_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "application_credential_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "application_credential_secret", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 13, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 14, name: "project_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "project_domain_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 16, name: "project_domain_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 17, name: "region_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 18, name: "container_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 19, name: "max_retries", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 20, name: "connect_timeout", kind: "message", T: Duration },
    { no: 21, name: "request_timeout", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwiftConfig {
    return new SwiftConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwiftConfig {
    return new SwiftConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwiftConfig {
    return new SwiftConfig().fromJsonString(jsonString, options);
  }

  static equals(a: SwiftConfig | PlainMessage<SwiftConfig> | undefined, b: SwiftConfig | PlainMessage<SwiftConfig> | undefined): boolean {
    return proto3.util.equals(SwiftConfig, a, b);
  }
}

