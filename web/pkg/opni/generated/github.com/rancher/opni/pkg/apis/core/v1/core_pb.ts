// @generated by protoc-gen-es v1.3.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file github.com/rancher/opni/pkg/apis/core/v1/core.proto (package core, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum core.MatchOptions
 */
export enum MatchOptions {
  /**
   * @generated from enum value: Default = 0;
   */
  Default = 0,

  /**
   * @generated from enum value: EmptySelectorMatchesAll = 0;
   */
  EmptySelectorMatchesAll = 0,

  /**
   * @generated from enum value: EmptySelectorMatchesNone = 1;
   */
  EmptySelectorMatchesNone = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(MatchOptions)
proto3.util.setEnumType(MatchOptions, "core.MatchOptions", [
  { no: 0, name: "Default" },
  { no: 0, name: "EmptySelectorMatchesAll" },
  { no: 1, name: "EmptySelectorMatchesNone" },
]);

/**
 * @generated from enum core.TaskState
 */
export enum TaskState {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: Pending = 1;
   */
  Pending = 1,

  /**
   * @generated from enum value: Running = 2;
   */
  Running = 2,

  /**
   * @generated from enum value: Completed = 3;
   */
  Completed = 3,

  /**
   * @generated from enum value: Failed = 4;
   */
  Failed = 4,

  /**
   * @generated from enum value: Canceled = 6;
   */
  Canceled = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskState)
proto3.util.setEnumType(TaskState, "core.TaskState", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "Pending" },
  { no: 2, name: "Running" },
  { no: 3, name: "Completed" },
  { no: 4, name: "Failed" },
  { no: 6, name: "Canceled" },
]);

/**
 * @generated from enum core.TaskTrigger
 */
export enum TaskTrigger {
  /**
   * @generated from enum value: Start = 0;
   */
  Start = 0,

  /**
   * @generated from enum value: End = 1;
   */
  End = 1,

  /**
   * @generated from enum value: Error = 2;
   */
  Error = 2,

  /**
   * @generated from enum value: Cancel = 3;
   */
  Cancel = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskTrigger)
proto3.util.setEnumType(TaskTrigger, "core.TaskTrigger", [
  { no: 0, name: "Start" },
  { no: 1, name: "End" },
  { no: 2, name: "Error" },
  { no: 3, name: "Cancel" },
]);

/**
 * @generated from enum core.ConfigStatus
 */
export enum ConfigStatus {
  /**
   * @generated from enum value: Unkown = 0;
   */
  Unkown = 0,

  /**
   * @generated from enum value: UpToDate = 1;
   */
  UpToDate = 1,

  /**
   * @generated from enum value: NeedsUpdate = 2;
   */
  NeedsUpdate = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigStatus)
proto3.util.setEnumType(ConfigStatus, "core.ConfigStatus", [
  { no: 0, name: "Unkown" },
  { no: 1, name: "UpToDate" },
  { no: 2, name: "NeedsUpdate" },
]);

/**
 * @generated from message core.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message core.BootstrapToken
 */
export class BootstrapToken extends Message<BootstrapToken> {
  /**
   * @generated from field: string tokenID = 1;
   */
  tokenID = "";

  /**
   * @generated from field: string secret = 2;
   */
  secret = "";

  /**
   * @generated from field: core.BootstrapTokenMetadata metadata = 3;
   */
  metadata?: BootstrapTokenMetadata;

  constructor(data?: PartialMessage<BootstrapToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BootstrapToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: BootstrapTokenMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootstrapToken {
    return new BootstrapToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootstrapToken {
    return new BootstrapToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootstrapToken {
    return new BootstrapToken().fromJsonString(jsonString, options);
  }

  static equals(a: BootstrapToken | PlainMessage<BootstrapToken> | undefined, b: BootstrapToken | PlainMessage<BootstrapToken> | undefined): boolean {
    return proto3.util.equals(BootstrapToken, a, b);
  }
}

/**
 * @generated from message core.BootstrapTokenMetadata
 */
export class BootstrapTokenMetadata extends Message<BootstrapTokenMetadata> {
  /**
   * @generated from field: int64 leaseID = 1;
   */
  leaseID = protoInt64.zero;

  /**
   * @generated from field: int64 ttl = 2;
   */
  ttl = protoInt64.zero;

  /**
   * @generated from field: int64 usageCount = 3;
   */
  usageCount = protoInt64.zero;

  /**
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string } = {};

  /**
   * @generated from field: repeated core.TokenCapability capabilities = 5;
   */
  capabilities: TokenCapability[] = [];

  /**
   * @generated from field: string resourceVersion = 6;
   */
  resourceVersion = "";

  /**
   * @generated from field: int64 maxUsages = 7;
   */
  maxUsages = protoInt64.zero;

  constructor(data?: PartialMessage<BootstrapTokenMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BootstrapTokenMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leaseID", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "ttl", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "usageCount", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "capabilities", kind: "message", T: TokenCapability, repeated: true },
    { no: 6, name: "resourceVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "maxUsages", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootstrapTokenMetadata {
    return new BootstrapTokenMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootstrapTokenMetadata {
    return new BootstrapTokenMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootstrapTokenMetadata {
    return new BootstrapTokenMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: BootstrapTokenMetadata | PlainMessage<BootstrapTokenMetadata> | undefined, b: BootstrapTokenMetadata | PlainMessage<BootstrapTokenMetadata> | undefined): boolean {
    return proto3.util.equals(BootstrapTokenMetadata, a, b);
  }
}

/**
 * @generated from message core.TokenCapability
 */
export class TokenCapability extends Message<TokenCapability> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: core.Reference reference = 2;
   */
  reference?: Reference;

  constructor(data?: PartialMessage<TokenCapability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.TokenCapability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reference", kind: "message", T: Reference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TokenCapability {
    return new TokenCapability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TokenCapability {
    return new TokenCapability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TokenCapability {
    return new TokenCapability().fromJsonString(jsonString, options);
  }

  static equals(a: TokenCapability | PlainMessage<TokenCapability> | undefined, b: TokenCapability | PlainMessage<TokenCapability> | undefined): boolean {
    return proto3.util.equals(TokenCapability, a, b);
  }
}

/**
 * @generated from message core.BootstrapTokenList
 */
export class BootstrapTokenList extends Message<BootstrapTokenList> {
  /**
   * @generated from field: repeated core.BootstrapToken items = 1;
   */
  items: BootstrapToken[] = [];

  constructor(data?: PartialMessage<BootstrapTokenList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BootstrapTokenList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: BootstrapToken, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootstrapTokenList {
    return new BootstrapTokenList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootstrapTokenList {
    return new BootstrapTokenList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootstrapTokenList {
    return new BootstrapTokenList().fromJsonString(jsonString, options);
  }

  static equals(a: BootstrapTokenList | PlainMessage<BootstrapTokenList> | undefined, b: BootstrapTokenList | PlainMessage<BootstrapTokenList> | undefined): boolean {
    return proto3.util.equals(BootstrapTokenList, a, b);
  }
}

/**
 * @generated from message core.Cluster
 */
export class Cluster extends Message<Cluster> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: core.ClusterMetadata metadata = 2;
   */
  metadata?: ClusterMetadata;

  constructor(data?: PartialMessage<Cluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Cluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: ClusterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cluster {
    return new Cluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJsonString(jsonString, options);
  }

  static equals(a: Cluster | PlainMessage<Cluster> | undefined, b: Cluster | PlainMessage<Cluster> | undefined): boolean {
    return proto3.util.equals(Cluster, a, b);
  }
}

/**
 * @generated from message core.ClusterMetadata
 */
export class ClusterMetadata extends Message<ClusterMetadata> {
  /**
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  /**
   * @generated from field: repeated core.ClusterCapability capabilities = 2;
   */
  capabilities: ClusterCapability[] = [];

  /**
   * read-only
   *
   * @generated from field: string resourceVersion = 3;
   */
  resourceVersion = "";

  /**
   * @generated from field: core.LastKnownConnectionDetails lastKnownConnectionDetails = 4;
   */
  lastKnownConnectionDetails?: LastKnownConnectionDetails;

  /**
   * read-only
   *
   * @generated from field: google.protobuf.Timestamp creationTimestamp = 5;
   */
  creationTimestamp?: Timestamp;

  constructor(data?: PartialMessage<ClusterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "capabilities", kind: "message", T: ClusterCapability, repeated: true },
    { no: 3, name: "resourceVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "lastKnownConnectionDetails", kind: "message", T: LastKnownConnectionDetails },
    { no: 5, name: "creationTimestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterMetadata {
    return new ClusterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterMetadata {
    return new ClusterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterMetadata {
    return new ClusterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterMetadata | PlainMessage<ClusterMetadata> | undefined, b: ClusterMetadata | PlainMessage<ClusterMetadata> | undefined): boolean {
    return proto3.util.equals(ClusterMetadata, a, b);
  }
}

/**
 * @generated from message core.LastKnownConnectionDetails
 */
export class LastKnownConnectionDetails extends Message<LastKnownConnectionDetails> {
  /**
   * @generated from field: google.protobuf.Timestamp time = 1;
   */
  time?: Timestamp;

  /**
   * @generated from field: string address = 2;
   */
  address = "";

  /**
   * @generated from field: core.BuildInfo agentBuildInfo = 3;
   */
  agentBuildInfo?: BuildInfo;

  /**
   * plugin package id -> hash
   *
   * @generated from field: map<string, string> pluginVersions = 4;
   */
  pluginVersions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<LastKnownConnectionDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.LastKnownConnectionDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time", kind: "message", T: Timestamp },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "agentBuildInfo", kind: "message", T: BuildInfo },
    { no: 4, name: "pluginVersions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LastKnownConnectionDetails {
    return new LastKnownConnectionDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LastKnownConnectionDetails {
    return new LastKnownConnectionDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LastKnownConnectionDetails {
    return new LastKnownConnectionDetails().fromJsonString(jsonString, options);
  }

  static equals(a: LastKnownConnectionDetails | PlainMessage<LastKnownConnectionDetails> | undefined, b: LastKnownConnectionDetails | PlainMessage<LastKnownConnectionDetails> | undefined): boolean {
    return proto3.util.equals(LastKnownConnectionDetails, a, b);
  }
}

/**
 * @generated from message core.BuildInfo
 */
export class BuildInfo extends Message<BuildInfo> {
  /**
   * @generated from field: string goVersion = 1;
   */
  goVersion = "";

  /**
   * @generated from field: string path = 2;
   */
  path = "";

  /**
   * @generated from field: core.Module main = 3;
   */
  main?: Module;

  /**
   * @generated from field: repeated core.Module deps = 4;
   */
  deps: Module[] = [];

  /**
   * @generated from field: repeated core.BuildSetting settings = 5;
   */
  settings: BuildSetting[] = [];

  constructor(data?: PartialMessage<BuildInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BuildInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "goVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "main", kind: "message", T: Module },
    { no: 4, name: "deps", kind: "message", T: Module, repeated: true },
    { no: 5, name: "settings", kind: "message", T: BuildSetting, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildInfo {
    return new BuildInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildInfo {
    return new BuildInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildInfo {
    return new BuildInfo().fromJsonString(jsonString, options);
  }

  static equals(a: BuildInfo | PlainMessage<BuildInfo> | undefined, b: BuildInfo | PlainMessage<BuildInfo> | undefined): boolean {
    return proto3.util.equals(BuildInfo, a, b);
  }
}

/**
 * @generated from message core.Module
 */
export class Module extends Message<Module> {
  /**
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: string sum = 3;
   */
  sum = "";

  /**
   * @generated from field: core.Module replace = 4;
   */
  replace?: Module;

  constructor(data?: PartialMessage<Module>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Module";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sum", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "replace", kind: "message", T: Module },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Module {
    return new Module().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJsonString(jsonString, options);
  }

  static equals(a: Module | PlainMessage<Module> | undefined, b: Module | PlainMessage<Module> | undefined): boolean {
    return proto3.util.equals(Module, a, b);
  }
}

/**
 * @generated from message core.BuildSetting
 */
export class BuildSetting extends Message<BuildSetting> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<BuildSetting>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BuildSetting";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildSetting {
    return new BuildSetting().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildSetting {
    return new BuildSetting().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildSetting {
    return new BuildSetting().fromJsonString(jsonString, options);
  }

  static equals(a: BuildSetting | PlainMessage<BuildSetting> | undefined, b: BuildSetting | PlainMessage<BuildSetting> | undefined): boolean {
    return proto3.util.equals(BuildSetting, a, b);
  }
}

/**
 * @generated from message core.ClusterCapability
 */
export class ClusterCapability extends Message<ClusterCapability> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: google.protobuf.Timestamp deletionTimestamp = 2;
   */
  deletionTimestamp?: Timestamp;

  constructor(data?: PartialMessage<ClusterCapability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterCapability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deletionTimestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterCapability {
    return new ClusterCapability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterCapability {
    return new ClusterCapability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterCapability {
    return new ClusterCapability().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterCapability | PlainMessage<ClusterCapability> | undefined, b: ClusterCapability | PlainMessage<ClusterCapability> | undefined): boolean {
    return proto3.util.equals(ClusterCapability, a, b);
  }
}

/**
 * @generated from message core.ClusterList
 */
export class ClusterList extends Message<ClusterList> {
  /**
   * @generated from field: repeated core.Cluster items = 1;
   */
  items: Cluster[] = [];

  constructor(data?: PartialMessage<ClusterList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Cluster, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterList {
    return new ClusterList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterList {
    return new ClusterList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterList {
    return new ClusterList().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterList | PlainMessage<ClusterList> | undefined, b: ClusterList | PlainMessage<ClusterList> | undefined): boolean {
    return proto3.util.equals(ClusterList, a, b);
  }
}

/**
 * @generated from message core.LabelSelector
 */
export class LabelSelector extends Message<LabelSelector> {
  /**
   * @generated from field: map<string, string> matchLabels = 1;
   */
  matchLabels: { [key: string]: string } = {};

  /**
   * @generated from field: repeated core.LabelSelectorRequirement matchExpressions = 2;
   */
  matchExpressions: LabelSelectorRequirement[] = [];

  constructor(data?: PartialMessage<LabelSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.LabelSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "matchLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "matchExpressions", kind: "message", T: LabelSelectorRequirement, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelSelector {
    return new LabelSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelSelector {
    return new LabelSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelSelector {
    return new LabelSelector().fromJsonString(jsonString, options);
  }

  static equals(a: LabelSelector | PlainMessage<LabelSelector> | undefined, b: LabelSelector | PlainMessage<LabelSelector> | undefined): boolean {
    return proto3.util.equals(LabelSelector, a, b);
  }
}

/**
 * @generated from message core.LabelSelectorRequirement
 */
export class LabelSelectorRequirement extends Message<LabelSelectorRequirement> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: string operator = 2;
   */
  operator = "";

  /**
   * @generated from field: repeated string values = 3;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<LabelSelectorRequirement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.LabelSelectorRequirement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "operator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelSelectorRequirement {
    return new LabelSelectorRequirement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelSelectorRequirement {
    return new LabelSelectorRequirement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelSelectorRequirement {
    return new LabelSelectorRequirement().fromJsonString(jsonString, options);
  }

  static equals(a: LabelSelectorRequirement | PlainMessage<LabelSelectorRequirement> | undefined, b: LabelSelectorRequirement | PlainMessage<LabelSelectorRequirement> | undefined): boolean {
    return proto3.util.equals(LabelSelectorRequirement, a, b);
  }
}

/**
 * @generated from message core.ClusterSelector
 */
export class ClusterSelector extends Message<ClusterSelector> {
  /**
   * @generated from field: repeated string clusterIDs = 1;
   */
  clusterIDs: string[] = [];

  /**
   * @generated from field: core.LabelSelector labelSelector = 2;
   */
  labelSelector?: LabelSelector;

  /**
   * @generated from field: core.MatchOptions matchOptions = 3;
   */
  matchOptions = MatchOptions.Default;

  constructor(data?: PartialMessage<ClusterSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clusterIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "labelSelector", kind: "message", T: LabelSelector },
    { no: 3, name: "matchOptions", kind: "enum", T: proto3.getEnumType(MatchOptions) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterSelector {
    return new ClusterSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterSelector {
    return new ClusterSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterSelector {
    return new ClusterSelector().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterSelector | PlainMessage<ClusterSelector> | undefined, b: ClusterSelector | PlainMessage<ClusterSelector> | undefined): boolean {
    return proto3.util.equals(ClusterSelector, a, b);
  }
}

/**
 * @generated from message core.RoleMetadata
 */
export class RoleMetadata extends Message<RoleMetadata> {
  /**
   * read-only
   *
   * @generated from field: string resourceVersion = 1;
   */
  resourceVersion = "";

  constructor(data?: PartialMessage<RoleMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.RoleMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resourceVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleMetadata {
    return new RoleMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleMetadata {
    return new RoleMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleMetadata {
    return new RoleMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: RoleMetadata | PlainMessage<RoleMetadata> | undefined, b: RoleMetadata | PlainMessage<RoleMetadata> | undefined): boolean {
    return proto3.util.equals(RoleMetadata, a, b);
  }
}

/**
 * @generated from message core.RoleBinding
 */
export class RoleBinding extends Message<RoleBinding> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string roleId = 2;
   */
  roleId = "";

  /**
   * @generated from field: repeated string subjects = 3;
   */
  subjects: string[] = [];

  /**
   * @generated from field: repeated string taints = 4;
   */
  taints: string[] = [];

  /**
   * @generated from field: core.RoleBindingMetadata metadata = 5;
   */
  metadata?: RoleBindingMetadata;

  constructor(data?: PartialMessage<RoleBinding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.RoleBinding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "roleId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "taints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "metadata", kind: "message", T: RoleBindingMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBinding {
    return new RoleBinding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBinding {
    return new RoleBinding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBinding {
    return new RoleBinding().fromJsonString(jsonString, options);
  }

  static equals(a: RoleBinding | PlainMessage<RoleBinding> | undefined, b: RoleBinding | PlainMessage<RoleBinding> | undefined): boolean {
    return proto3.util.equals(RoleBinding, a, b);
  }
}

/**
 * @generated from message core.RoleBindingMetadata
 */
export class RoleBindingMetadata extends Message<RoleBindingMetadata> {
  /**
   * read-only
   *
   * @generated from field: string resourceVersion = 1;
   */
  resourceVersion = "";

  /**
   * immutable after creation
   *
   * @generated from field: optional string capability = 2;
   */
  capability?: string;

  constructor(data?: PartialMessage<RoleBindingMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.RoleBindingMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resourceVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "capability", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBindingMetadata {
    return new RoleBindingMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBindingMetadata {
    return new RoleBindingMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBindingMetadata {
    return new RoleBindingMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: RoleBindingMetadata | PlainMessage<RoleBindingMetadata> | undefined, b: RoleBindingMetadata | PlainMessage<RoleBindingMetadata> | undefined): boolean {
    return proto3.util.equals(RoleBindingMetadata, a, b);
  }
}

/**
 * @generated from message core.RoleBindingList
 */
export class RoleBindingList extends Message<RoleBindingList> {
  /**
   * @generated from field: repeated core.RoleBinding items = 1;
   */
  items: RoleBinding[] = [];

  constructor(data?: PartialMessage<RoleBindingList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.RoleBindingList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: RoleBinding, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleBindingList {
    return new RoleBindingList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleBindingList {
    return new RoleBindingList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleBindingList {
    return new RoleBindingList().fromJsonString(jsonString, options);
  }

  static equals(a: RoleBindingList | PlainMessage<RoleBindingList> | undefined, b: RoleBindingList | PlainMessage<RoleBindingList> | undefined): boolean {
    return proto3.util.equals(RoleBindingList, a, b);
  }
}

/**
 * @generated from message core.CapabilityType
 */
export class CapabilityType extends Message<CapabilityType> {
  /**
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<CapabilityType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.CapabilityType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CapabilityType {
    return new CapabilityType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CapabilityType {
    return new CapabilityType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CapabilityType {
    return new CapabilityType().fromJsonString(jsonString, options);
  }

  static equals(a: CapabilityType | PlainMessage<CapabilityType> | undefined, b: CapabilityType | PlainMessage<CapabilityType> | undefined): boolean {
    return proto3.util.equals(CapabilityType, a, b);
  }
}

/**
 * @generated from message core.CapabilityTypeList
 */
export class CapabilityTypeList extends Message<CapabilityTypeList> {
  /**
   * @generated from field: repeated string names = 2;
   */
  names: string[] = [];

  constructor(data?: PartialMessage<CapabilityTypeList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.CapabilityTypeList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CapabilityTypeList {
    return new CapabilityTypeList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CapabilityTypeList {
    return new CapabilityTypeList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CapabilityTypeList {
    return new CapabilityTypeList().fromJsonString(jsonString, options);
  }

  static equals(a: CapabilityTypeList | PlainMessage<CapabilityTypeList> | undefined, b: CapabilityTypeList | PlainMessage<CapabilityTypeList> | undefined): boolean {
    return proto3.util.equals(CapabilityTypeList, a, b);
  }
}

/**
 * @generated from message core.PermissionVerb
 */
export class PermissionVerb extends Message<PermissionVerb> {
  /**
   * @generated from field: string verb = 1;
   */
  verb = "";

  constructor(data?: PartialMessage<PermissionVerb>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.PermissionVerb";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verb", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermissionVerb {
    return new PermissionVerb().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermissionVerb {
    return new PermissionVerb().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermissionVerb {
    return new PermissionVerb().fromJsonString(jsonString, options);
  }

  static equals(a: PermissionVerb | PlainMessage<PermissionVerb> | undefined, b: PermissionVerb | PlainMessage<PermissionVerb> | undefined): boolean {
    return proto3.util.equals(PermissionVerb, a, b);
  }
}

/**
 * @generated from message core.PermissionDescription
 */
export class PermissionDescription extends Message<PermissionDescription> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: repeated core.PermissionVerb verbs = 2;
   */
  verbs: PermissionVerb[] = [];

  constructor(data?: PartialMessage<PermissionDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.PermissionDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "verbs", kind: "message", T: PermissionVerb, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermissionDescription {
    return new PermissionDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermissionDescription {
    return new PermissionDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermissionDescription {
    return new PermissionDescription().fromJsonString(jsonString, options);
  }

  static equals(a: PermissionDescription | PlainMessage<PermissionDescription> | undefined, b: PermissionDescription | PlainMessage<PermissionDescription> | undefined): boolean {
    return proto3.util.equals(PermissionDescription, a, b);
  }
}

/**
 * @generated from message core.AvailablePermissions
 */
export class AvailablePermissions extends Message<AvailablePermissions> {
  /**
   * @generated from field: repeated core.PermissionDescription items = 1;
   */
  items: PermissionDescription[] = [];

  constructor(data?: PartialMessage<AvailablePermissions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.AvailablePermissions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: PermissionDescription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AvailablePermissions {
    return new AvailablePermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AvailablePermissions {
    return new AvailablePermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AvailablePermissions {
    return new AvailablePermissions().fromJsonString(jsonString, options);
  }

  static equals(a: AvailablePermissions | PlainMessage<AvailablePermissions> | undefined, b: AvailablePermissions | PlainMessage<AvailablePermissions> | undefined): boolean {
    return proto3.util.equals(AvailablePermissions, a, b);
  }
}

/**
 * @generated from message core.PermissionItem
 */
export class PermissionItem extends Message<PermissionItem> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: repeated core.PermissionVerb verbs = 2;
   */
  verbs: PermissionVerb[] = [];

  /**
   * @generated from field: repeated string ids = 3;
   */
  ids: string[] = [];

  /**
   * @generated from field: core.LabelSelector matchLabels = 4;
   */
  matchLabels?: LabelSelector;

  constructor(data?: PartialMessage<PermissionItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.PermissionItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "verbs", kind: "message", T: PermissionVerb, repeated: true },
    { no: 3, name: "ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "matchLabels", kind: "message", T: LabelSelector },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermissionItem {
    return new PermissionItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermissionItem {
    return new PermissionItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermissionItem {
    return new PermissionItem().fromJsonString(jsonString, options);
  }

  static equals(a: PermissionItem | PlainMessage<PermissionItem> | undefined, b: PermissionItem | PlainMessage<PermissionItem> | undefined): boolean {
    return proto3.util.equals(PermissionItem, a, b);
  }
}

/**
 * @generated from message core.Role
 */
export class Role extends Message<Role> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: repeated core.PermissionItem permissions = 2;
   */
  permissions: PermissionItem[] = [];

  /**
   * @generated from field: core.RoleMetadata metadata = 3;
   */
  metadata?: RoleMetadata;

  constructor(data?: PartialMessage<Role>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Role";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "permissions", kind: "message", T: PermissionItem, repeated: true },
    { no: 3, name: "metadata", kind: "message", T: RoleMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Role {
    return new Role().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJsonString(jsonString, options);
  }

  static equals(a: Role | PlainMessage<Role> | undefined, b: Role | PlainMessage<Role> | undefined): boolean {
    return proto3.util.equals(Role, a, b);
  }
}

/**
 * @generated from message core.BackendRole
 */
export class BackendRole extends Message<BackendRole> {
  /**
   * @generated from field: core.CapabilityType capability = 1;
   */
  capability?: CapabilityType;

  /**
   * @generated from field: core.Role role = 2;
   */
  role?: Role;

  constructor(data?: PartialMessage<BackendRole>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BackendRole";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "capability", kind: "message", T: CapabilityType },
    { no: 2, name: "role", kind: "message", T: Role },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BackendRole {
    return new BackendRole().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BackendRole {
    return new BackendRole().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BackendRole {
    return new BackendRole().fromJsonString(jsonString, options);
  }

  static equals(a: BackendRole | PlainMessage<BackendRole> | undefined, b: BackendRole | PlainMessage<BackendRole> | undefined): boolean {
    return proto3.util.equals(BackendRole, a, b);
  }
}

/**
 * @generated from message core.BackendRoleRequest
 */
export class BackendRoleRequest extends Message<BackendRoleRequest> {
  /**
   * @generated from field: core.CapabilityType capability = 1;
   */
  capability?: CapabilityType;

  /**
   * @generated from field: core.Reference roleRef = 2;
   */
  roleRef?: Reference;

  constructor(data?: PartialMessage<BackendRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.BackendRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "capability", kind: "message", T: CapabilityType },
    { no: 2, name: "roleRef", kind: "message", T: Reference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BackendRoleRequest {
    return new BackendRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BackendRoleRequest {
    return new BackendRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BackendRoleRequest {
    return new BackendRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BackendRoleRequest | PlainMessage<BackendRoleRequest> | undefined, b: BackendRoleRequest | PlainMessage<BackendRoleRequest> | undefined): boolean {
    return proto3.util.equals(BackendRoleRequest, a, b);
  }
}

/**
 * @generated from message core.RoleList
 */
export class RoleList extends Message<RoleList> {
  /**
   * @generated from field: repeated core.Reference items = 1;
   */
  items: Reference[] = [];

  constructor(data?: PartialMessage<RoleList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.RoleList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Reference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleList {
    return new RoleList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleList {
    return new RoleList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleList {
    return new RoleList().fromJsonString(jsonString, options);
  }

  static equals(a: RoleList | PlainMessage<RoleList> | undefined, b: RoleList | PlainMessage<RoleList> | undefined): boolean {
    return proto3.util.equals(RoleList, a, b);
  }
}

/**
 * @generated from message core.CertInfo
 */
export class CertInfo extends Message<CertInfo> {
  /**
   * @generated from field: string issuer = 1;
   */
  issuer = "";

  /**
   * @generated from field: string subject = 2;
   */
  subject = "";

  /**
   * @generated from field: bool isCA = 3;
   */
  isCA = false;

  /**
   * @generated from field: string notBefore = 4;
   */
  notBefore = "";

  /**
   * @generated from field: string notAfter = 5;
   */
  notAfter = "";

  /**
   * @generated from field: string fingerprint = 6;
   */
  fingerprint = "";

  /**
   * @generated from field: bytes raw = 7;
   */
  raw = new Uint8Array(0);

  constructor(data?: PartialMessage<CertInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.CertInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "issuer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subject", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isCA", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "notBefore", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "notAfter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "fingerprint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertInfo {
    return new CertInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertInfo {
    return new CertInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertInfo {
    return new CertInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CertInfo | PlainMessage<CertInfo> | undefined, b: CertInfo | PlainMessage<CertInfo> | undefined): boolean {
    return proto3.util.equals(CertInfo, a, b);
  }
}

/**
 * @generated from message core.Reference
 */
export class Reference extends Message<Reference> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<Reference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Reference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reference {
    return new Reference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJsonString(jsonString, options);
  }

  static equals(a: Reference | PlainMessage<Reference> | undefined, b: Reference | PlainMessage<Reference> | undefined): boolean {
    return proto3.util.equals(Reference, a, b);
  }
}

/**
 * @generated from message core.ReferenceList
 */
export class ReferenceList extends Message<ReferenceList> {
  /**
   * @generated from field: repeated core.Reference items = 1;
   */
  items: Reference[] = [];

  constructor(data?: PartialMessage<ReferenceList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ReferenceList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: Reference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReferenceList {
    return new ReferenceList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReferenceList {
    return new ReferenceList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReferenceList {
    return new ReferenceList().fromJsonString(jsonString, options);
  }

  static equals(a: ReferenceList | PlainMessage<ReferenceList> | undefined, b: ReferenceList | PlainMessage<ReferenceList> | undefined): boolean {
    return proto3.util.equals(ReferenceList, a, b);
  }
}

/**
 * @generated from message core.SubjectAccessRequest
 */
export class SubjectAccessRequest extends Message<SubjectAccessRequest> {
  /**
   * @generated from field: string subject = 1;
   */
  subject = "";

  constructor(data?: PartialMessage<SubjectAccessRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.SubjectAccessRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subject", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectAccessRequest {
    return new SubjectAccessRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectAccessRequest {
    return new SubjectAccessRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectAccessRequest {
    return new SubjectAccessRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubjectAccessRequest | PlainMessage<SubjectAccessRequest> | undefined, b: SubjectAccessRequest | PlainMessage<SubjectAccessRequest> | undefined): boolean {
    return proto3.util.equals(SubjectAccessRequest, a, b);
  }
}

/**
 * @generated from message core.Status
 */
export class Status extends Message<Status> {
  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: bool connected = 2;
   */
  connected = false;

  /**
   * @generated from field: repeated string sessionAttributes = 3;
   */
  sessionAttributes: string[] = [];

  constructor(data?: PartialMessage<Status>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Status";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "connected", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "sessionAttributes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Status {
    return new Status().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Status {
    return new Status().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Status {
    return new Status().fromJsonString(jsonString, options);
  }

  static equals(a: Status | PlainMessage<Status> | undefined, b: Status | PlainMessage<Status> | undefined): boolean {
    return proto3.util.equals(Status, a, b);
  }
}

/**
 * @generated from message core.Health
 */
export class Health extends Message<Health> {
  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: bool ready = 2;
   */
  ready = false;

  /**
   * @generated from field: repeated string conditions = 3;
   */
  conditions: string[] = [];

  /**
   * @generated from field: map<string, string> annotations = 4;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Health>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Health";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "ready", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "conditions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Health {
    return new Health().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Health {
    return new Health().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Health {
    return new Health().fromJsonString(jsonString, options);
  }

  static equals(a: Health | PlainMessage<Health> | undefined, b: Health | PlainMessage<Health> | undefined): boolean {
    return proto3.util.equals(Health, a, b);
  }
}

/**
 * @generated from message core.HealthStatus
 */
export class HealthStatus extends Message<HealthStatus> {
  /**
   * @generated from field: core.Health health = 1;
   */
  health?: Health;

  /**
   * @generated from field: core.Status status = 2;
   */
  status?: Status;

  constructor(data?: PartialMessage<HealthStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.HealthStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "health", kind: "message", T: Health },
    { no: 2, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthStatus {
    return new HealthStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthStatus {
    return new HealthStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthStatus {
    return new HealthStatus().fromJsonString(jsonString, options);
  }

  static equals(a: HealthStatus | PlainMessage<HealthStatus> | undefined, b: HealthStatus | PlainMessage<HealthStatus> | undefined): boolean {
    return proto3.util.equals(HealthStatus, a, b);
  }
}

/**
 * @generated from message core.ClusterHealth
 */
export class ClusterHealth extends Message<ClusterHealth> {
  /**
   * @generated from field: core.Reference cluster = 1;
   */
  cluster?: Reference;

  /**
   * @generated from field: core.Health health = 2;
   */
  health?: Health;

  constructor(data?: PartialMessage<ClusterHealth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterHealth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster", kind: "message", T: Reference },
    { no: 2, name: "health", kind: "message", T: Health },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterHealth {
    return new ClusterHealth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterHealth {
    return new ClusterHealth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterHealth {
    return new ClusterHealth().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterHealth | PlainMessage<ClusterHealth> | undefined, b: ClusterHealth | PlainMessage<ClusterHealth> | undefined): boolean {
    return proto3.util.equals(ClusterHealth, a, b);
  }
}

/**
 * @generated from message core.ClusterStatus
 */
export class ClusterStatus extends Message<ClusterStatus> {
  /**
   * @generated from field: core.Reference cluster = 1;
   */
  cluster?: Reference;

  /**
   * @generated from field: core.Status status = 2;
   */
  status?: Status;

  constructor(data?: PartialMessage<ClusterStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster", kind: "message", T: Reference },
    { no: 2, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterStatus {
    return new ClusterStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterStatus {
    return new ClusterStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterStatus {
    return new ClusterStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterStatus | PlainMessage<ClusterStatus> | undefined, b: ClusterStatus | PlainMessage<ClusterStatus> | undefined): boolean {
    return proto3.util.equals(ClusterStatus, a, b);
  }
}

/**
 * @generated from message core.ClusterHealthStatus
 */
export class ClusterHealthStatus extends Message<ClusterHealthStatus> {
  /**
   * @generated from field: core.Reference cluster = 1;
   */
  cluster?: Reference;

  /**
   * @generated from field: core.HealthStatus healthStatus = 2;
   */
  healthStatus?: HealthStatus;

  constructor(data?: PartialMessage<ClusterHealthStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ClusterHealthStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster", kind: "message", T: Reference },
    { no: 2, name: "healthStatus", kind: "message", T: HealthStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterHealthStatus {
    return new ClusterHealthStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterHealthStatus {
    return new ClusterHealthStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterHealthStatus {
    return new ClusterHealthStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterHealthStatus | PlainMessage<ClusterHealthStatus> | undefined, b: ClusterHealthStatus | PlainMessage<ClusterHealthStatus> | undefined): boolean {
    return proto3.util.equals(ClusterHealthStatus, a, b);
  }
}

/**
 * @generated from message core.AlertLog
 */
export class AlertLog extends Message<AlertLog> {
  /**
   * @generated from field: core.Reference conditionId = 1;
   */
  conditionId?: Reference;

  /**
   * unix epoch timestamp
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: google.protobuf.Struct metadata = 4;
   */
  metadata?: Struct;

  constructor(data?: PartialMessage<AlertLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.AlertLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditionId", kind: "message", T: Reference },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
    { no: 4, name: "metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertLog {
    return new AlertLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertLog {
    return new AlertLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertLog {
    return new AlertLog().fromJsonString(jsonString, options);
  }

  static equals(a: AlertLog | PlainMessage<AlertLog> | undefined, b: AlertLog | PlainMessage<AlertLog> | undefined): boolean {
    return proto3.util.equals(AlertLog, a, b);
  }
}

/**
 * @generated from message core.AlertLogList
 */
export class AlertLogList extends Message<AlertLogList> {
  /**
   * @generated from field: repeated core.AlertLog Items = 1;
   */
  Items: AlertLog[] = [];

  constructor(data?: PartialMessage<AlertLogList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.AlertLogList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Items", kind: "message", T: AlertLog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertLogList {
    return new AlertLogList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertLogList {
    return new AlertLogList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertLogList {
    return new AlertLogList().fromJsonString(jsonString, options);
  }

  static equals(a: AlertLogList | PlainMessage<AlertLogList> | undefined, b: AlertLogList | PlainMessage<AlertLogList> | undefined): boolean {
    return proto3.util.equals(AlertLogList, a, b);
  }
}

/**
 * @generated from message core.TimeRange
 */
export class TimeRange extends Message<TimeRange> {
  /**
   * @generated from field: uint64 start = 1;
   */
  start = protoInt64.zero;

  /**
   * @generated from field: uint64 end = 2;
   */
  end = protoInt64.zero;

  constructor(data?: PartialMessage<TimeRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.TimeRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "end", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeRange {
    return new TimeRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJsonString(jsonString, options);
  }

  static equals(a: TimeRange | PlainMessage<TimeRange> | undefined, b: TimeRange | PlainMessage<TimeRange> | undefined): boolean {
    return proto3.util.equals(TimeRange, a, b);
  }
}

/**
 * Represents a transition to a task state at a point in time.
 *
 * @generated from message core.StateTransition
 */
export class StateTransition extends Message<StateTransition> {
  /**
   * @generated from field: core.TaskState state = 1;
   */
  state = TaskState.Unknown;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<StateTransition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.StateTransition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(TaskState) },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StateTransition {
    return new StateTransition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StateTransition {
    return new StateTransition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StateTransition {
    return new StateTransition().fromJsonString(jsonString, options);
  }

  static equals(a: StateTransition | PlainMessage<StateTransition> | undefined, b: StateTransition | PlainMessage<StateTransition> | undefined): boolean {
    return proto3.util.equals(StateTransition, a, b);
  }
}

/**
 * @generated from message core.Progress
 */
export class Progress extends Message<Progress> {
  /**
   * @generated from field: uint64 current = 1;
   */
  current = protoInt64.zero;

  /**
   * @generated from field: uint64 total = 2;
   */
  total = protoInt64.zero;

  constructor(data?: PartialMessage<Progress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Progress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "total", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Progress {
    return new Progress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Progress {
    return new Progress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Progress {
    return new Progress().fromJsonString(jsonString, options);
  }

  static equals(a: Progress | PlainMessage<Progress> | undefined, b: Progress | PlainMessage<Progress> | undefined): boolean {
    return proto3.util.equals(Progress, a, b);
  }
}

/**
 * @generated from message core.TaskStatus
 */
export class TaskStatus extends Message<TaskStatus> {
  /**
   * @generated from field: core.TaskState state = 1;
   */
  state = TaskState.Unknown;

  /**
   * @generated from field: core.Progress progress = 2;
   */
  progress?: Progress;

  /**
   * @generated from field: string metadata = 3;
   */
  metadata = "";

  /**
   * @generated from field: repeated core.LogEntry logs = 4;
   */
  logs: LogEntry[] = [];

  /**
   * @generated from field: repeated core.StateTransition transitions = 5;
   */
  transitions: StateTransition[] = [];

  constructor(data?: PartialMessage<TaskStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.TaskStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(TaskState) },
    { no: 2, name: "progress", kind: "message", T: Progress },
    { no: 3, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "logs", kind: "message", T: LogEntry, repeated: true },
    { no: 5, name: "transitions", kind: "message", T: StateTransition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskStatus {
    return new TaskStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskStatus {
    return new TaskStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskStatus {
    return new TaskStatus().fromJsonString(jsonString, options);
  }

  static equals(a: TaskStatus | PlainMessage<TaskStatus> | undefined, b: TaskStatus | PlainMessage<TaskStatus> | undefined): boolean {
    return proto3.util.equals(TaskStatus, a, b);
  }
}

/**
 * @generated from message core.LogEntry
 */
export class LogEntry extends Message<LogEntry> {
  /**
   * @generated from field: string msg = 1;
   */
  msg = "";

  /**
   * @generated from field: int32 level = 2;
   */
  level = 0;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<LogEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.LogEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "level", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogEntry {
    return new LogEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogEntry {
    return new LogEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogEntry {
    return new LogEntry().fromJsonString(jsonString, options);
  }

  static equals(a: LogEntry | PlainMessage<LogEntry> | undefined, b: LogEntry | PlainMessage<LogEntry> | undefined): boolean {
    return proto3.util.equals(LogEntry, a, b);
  }
}

/**
 * @generated from message core.ChallengeRequestList
 */
export class ChallengeRequestList extends Message<ChallengeRequestList> {
  /**
   * @generated from field: repeated core.ChallengeRequest items = 2040;
   */
  items: ChallengeRequest[] = [];

  constructor(data?: PartialMessage<ChallengeRequestList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ChallengeRequestList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2040, name: "items", kind: "message", T: ChallengeRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChallengeRequestList {
    return new ChallengeRequestList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChallengeRequestList {
    return new ChallengeRequestList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChallengeRequestList {
    return new ChallengeRequestList().fromJsonString(jsonString, options);
  }

  static equals(a: ChallengeRequestList | PlainMessage<ChallengeRequestList> | undefined, b: ChallengeRequestList | PlainMessage<ChallengeRequestList> | undefined): boolean {
    return proto3.util.equals(ChallengeRequestList, a, b);
  }
}

/**
 * @generated from message core.ChallengeRequest
 */
export class ChallengeRequest extends Message<ChallengeRequest> {
  /**
   * @generated from field: bytes challenge = 2042;
   */
  challenge = new Uint8Array(0);

  constructor(data?: PartialMessage<ChallengeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ChallengeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2042, name: "challenge", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChallengeRequest {
    return new ChallengeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChallengeRequest {
    return new ChallengeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChallengeRequest {
    return new ChallengeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ChallengeRequest | PlainMessage<ChallengeRequest> | undefined, b: ChallengeRequest | PlainMessage<ChallengeRequest> | undefined): boolean {
    return proto3.util.equals(ChallengeRequest, a, b);
  }
}

/**
 * @generated from message core.ChallengeResponseList
 */
export class ChallengeResponseList extends Message<ChallengeResponseList> {
  /**
   * @generated from field: repeated core.ChallengeResponse items = 2045;
   */
  items: ChallengeResponse[] = [];

  constructor(data?: PartialMessage<ChallengeResponseList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ChallengeResponseList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2045, name: "items", kind: "message", T: ChallengeResponse, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChallengeResponseList {
    return new ChallengeResponseList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChallengeResponseList {
    return new ChallengeResponseList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChallengeResponseList {
    return new ChallengeResponseList().fromJsonString(jsonString, options);
  }

  static equals(a: ChallengeResponseList | PlainMessage<ChallengeResponseList> | undefined, b: ChallengeResponseList | PlainMessage<ChallengeResponseList> | undefined): boolean {
    return proto3.util.equals(ChallengeResponseList, a, b);
  }
}

/**
 * @generated from message core.ChallengeResponse
 */
export class ChallengeResponse extends Message<ChallengeResponse> {
  /**
   * @generated from field: bytes response = 2047;
   */
  response = new Uint8Array(0);

  constructor(data?: PartialMessage<ChallengeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.ChallengeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2047, name: "response", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChallengeResponse {
    return new ChallengeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChallengeResponse {
    return new ChallengeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChallengeResponse {
    return new ChallengeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ChallengeResponse | PlainMessage<ChallengeResponse> | undefined, b: ChallengeResponse | PlainMessage<ChallengeResponse> | undefined): boolean {
    return proto3.util.equals(ChallengeResponse, a, b);
  }
}

/**
 * @generated from message core.SessionInfo
 */
export class SessionInfo extends Message<SessionInfo> {
  /**
   * @generated from field: repeated string attributes = 2051;
   */
  attributes: string[] = [];

  /**
   * @generated from field: bytes mac = 2056;
   */
  mac = new Uint8Array(0);

  constructor(data?: PartialMessage<SessionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.SessionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2051, name: "attributes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2056, name: "mac", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionInfo {
    return new SessionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionInfo {
    return new SessionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionInfo {
    return new SessionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SessionInfo | PlainMessage<SessionInfo> | undefined, b: SessionInfo | PlainMessage<SessionInfo> | undefined): boolean {
    return proto3.util.equals(SessionInfo, a, b);
  }
}

/**
 * @generated from message core.AuthInfo
 */
export class AuthInfo extends Message<AuthInfo> {
  /**
   * @generated from field: string authorizedId = 2057;
   */
  authorizedId = "";

  /**
   * @generated from field: bytes mac = 2061;
   */
  mac = new Uint8Array(0);

  constructor(data?: PartialMessage<AuthInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.AuthInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2057, name: "authorizedId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2061, name: "mac", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthInfo {
    return new AuthInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthInfo {
    return new AuthInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthInfo {
    return new AuthInfo().fromJsonString(jsonString, options);
  }

  static equals(a: AuthInfo | PlainMessage<AuthInfo> | undefined, b: AuthInfo | PlainMessage<AuthInfo> | undefined): boolean {
    return proto3.util.equals(AuthInfo, a, b);
  }
}

/**
 * @generated from message core.Revision
 */
export class Revision extends Message<Revision> {
  /**
   * A numerical revision uniquely identifying a specific version of the resource.
   * Larger values are newer, but this should otherwise be treated as opaque.
   *
   * @generated from field: optional int64 revision = 1;
   */
  revision?: bigint;

  /**
   * An optional timestamp corresponding to the time the revision was created.
   * Do not depend on this field being set; if it is, it is for informational
   * purposes only.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<Revision>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "core.Revision";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "revision", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Revision {
    return new Revision().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Revision {
    return new Revision().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Revision {
    return new Revision().fromJsonString(jsonString, options);
  }

  static equals(a: Revision | PlainMessage<Revision> | undefined, b: Revision | PlainMessage<Revision> | undefined): boolean {
    return proto3.util.equals(Revision, a, b);
  }
}

