syntax = "proto3";
option go_package = "github.com/rancher/opni/plugins/alerting/pkg/apis/alertops";

import "google/protobuf/empty.proto";
import "github.com/rancher/opni/pkg/apis/storage/v1/storage.proto";
import "google/api/annotations.proto";

package alerting.ops;


// The AlertingAdmin service controls meta-operations for
// deploying, connecting & configuring AlertManager in the upstream environment
service AlertingAdmin {
    rpc GetClusterConfiguration(google.protobuf.Empty) returns (ClusterConfiguration) {
        option (google.api.http) = {
          get: "/configuration"
        };
      }
      // Install/Uninstall the alerting cluster by setting enabled=true/false
      rpc ConfigureCluster(ClusterConfiguration) returns (google.protobuf.Empty) {
        option (google.api.http) = {
          post: "/configure"
          body: "*"
        };
      }
      rpc GetClusterStatus(google.protobuf.Empty) returns (InstallStatus) {
        option (google.api.http) = {
          get: "/status"
        };
      }

      rpc InstallCluster(google.protobuf.Empty) returns (google.protobuf.Empty) {
        option (google.api.http) = {
          post: "/install"
        };
      }
      rpc UninstallCluster(google.protobuf.Empty) returns (google.protobuf.Empty) {
        option (google.api.http) = {
          post: "/uninstall"
        };
      }
}

// !! opni alerting internal only server
// Service implemented by the alerting cluster driver
// to rollout updates to the alert manager config map 
service DynamicAlerting {
  rpc Fetch(google.protobuf.Empty) returns (AlertingConfig) {
    option (google.api.http) = {
      get: "/fetch"
    };
  }

  rpc Update(AlertingConfig) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/update"
      body: "*"
    };
  }

  rpc GetStatus(google.protobuf.Empty) returns (DynamicStatus) {
    option (google.api.http) = {
      get: "/status"
    };
  }

  rpc Reload(ReloadInfo) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/reload"
    };
  }
}

message ReloadInfo{
  string updatedKey = 1;
}

message AlertingConfig{
  string raw = 1;
}

message DynamicStatus{
  DynamicState state = 1;
}

enum DynamicState {
  DyanmicUnknown = 0;
  DynamicUpdating = 1;
  Ready = 2;
}

enum InstallState {
    InstallUnknown = 0;
    NotInstalled = 1;
    InstallUpdating = 2;
    Installed = 3;
    Uninstalling = 4;
  }

message InstallStatus {
    InstallState state = 1;
    string version = 2;
    map<string, string> metadata = 3;
}

message ClusterConfiguration {
    // number of replicas for the opni-alerting (odd-number for HA)
    int32 numReplicas = 2;
    
    // Maximum time to wait for cluster
    // connections to settle before
    // evaluating notifications.
    string clusterSettleTimeout = 3;
    // Interval for gossip state syncs.
    // Setting this interval lower
    // (more frequent) will increase
    // convergence speeds across larger
    // clusters at the expense of
    // increased bandwidth usage.
    string clusterPushPullInterval = 4;
    // Interval between sending gossip
    // messages. By lowering this
    // value (more frequent) gossip
    // messages are propagated across
    // the cluster more quickly at the
    // expense of increased bandwidth.
    string clusterGossipInterval = 5;

    ResourceLimitSpec resourceLimits = 6;
}

message ResourceLimitSpec {
    // Storage resource limit for alerting volume
    string storage = 1;
    // CPU resource limit per replica
    string cpu = 2;
    // Memory resource limit per replica
    string memory = 3;
}