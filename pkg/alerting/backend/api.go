package backend

import (
	"fmt"
	"time"

	alertingv1 "github.com/rancher/opni/pkg/apis/alerting/v1"
	corev1 "github.com/rancher/opni/pkg/apis/core/v1"

	"github.com/go-openapi/strfmt"
)

/*
Autogenerated API structs based on AlertManager's openapi spec.
*/

// AlertGroup struct for AlertGroup
type AlertGroup struct {
	Labels   map[string]string `json:"labels"`
	Receiver Receiver          `json:"receiver"`
	Alerts   []GettableAlert   `json:"alerts"`
}

// GettableAlert gettable alert
//
// swagger:model gettableAlert
type GettableAlert struct {

	// annotations
	// Required: true
	Annotations LabelSet `json:"annotations"`

	// ends at
	// Required: true
	// Format: date-time
	EndsAt *strfmt.DateTime `json:"endsAt"`

	// fingerprint
	// Required: true
	Fingerprint *string `json:"fingerprint"`

	// receivers
	// Required: true
	Receivers []*Receiver `json:"receivers"`

	// starts at
	// Required: true
	// Format: date-time
	StartsAt *strfmt.DateTime `json:"startsAt"`

	// status
	// Required: true
	Status *AlertStatus `json:"status"`

	// updated at
	// Required: true
	// Format: date-time
	UpdatedAt *strfmt.DateTime `json:"updatedAt"`

	Alert
}

// Alert alert
//
// swagger:model alert
type Alert struct {

	// generator URL
	// Format: uri
	GeneratorURL strfmt.URI `json:"generatorURL,omitempty"`

	// labels
	// Required: true
	Labels LabelSet `json:"labels"`
}

type AlertStatus struct {

	// inhibited by
	// Required: true
	InhibitedBy []string `json:"inhibitedBy"`

	// silenced by
	// Required: true
	SilencedBy []string `json:"silencedBy"`

	// state
	// Required: true
	// Enum: [unprocessed active suppressed]
	State *string `json:"state"`
}

// Receiver receiver
//
// swagger:model receiver
type Receiver struct {

	// name
	// Required: true
	Name *string `json:"name"`
}

type LabelSet map[string]string

// PostableAlert : corresponds to the data AlertManager API
// needs to trigger alerts
type PostableAlert struct {
	StartsAt     *time.Time         `json:"startsAt,omitempty"`
	EndsAt       *time.Time         `json:"endsAt,omitempty"`
	Annotations  *map[string]string `json:"annotations,omitempty"`
	Labels       map[string]string  `json:"labels"`
	GeneratorURL *string            `json:"generatorURL,omitempty"`
}

// WithCondition In our basic model each receiver is uniquely
// identified by its name, which in AlertManager can be routed
// to by the label `alertname`.
func (p *PostableAlert) WithCondition(conditionId string) {
	if p.Labels == nil {
		p.Labels = make(map[string]string)
	}
	p.Labels["alertname"] = conditionId
	p.Labels["conditionId"] = conditionId
}

// WithRuntimeInfo adds the runtime information to the alert.
func (p *PostableAlert) WithRuntimeInfo(key string, value string) {
	if p.Annotations == nil {
		newMap := map[string]string{}
		p.Annotations = &newMap
	}
	(*p.Annotations)[key] = value
}

func (p *PostableAlert) Must() error {
	if p.Labels == nil {
		return fmt.Errorf("missting PostableAlert.Labels")
	}
	if v, ok := p.Labels["alertname"]; !ok || v == "" {
		return fmt.Errorf(`missting PostableAlert.Labels["alertname"]`)
	}
	return nil
}

type Matcher struct {
	Name    string `json:"name"`
	Value   string `json:"value"`
	IsRegex bool   `json:"isRegex"`
	IsEqual *bool  `json:"isEqual,omitempty"`
}

// PostableSilence struct for PostableSilence
type PostableSilence struct {
	Id        *string   `json:"id,omitempty"`
	Matchers  []Matcher `json:"matchers"`
	StartsAt  time.Time `json:"startsAt"`
	EndsAt    time.Time `json:"endsAt"`
	CreatedBy string    `json:"createdBy"`
	Comment   string    `json:"comment"`
}

type PostSilencesResponse struct {
	SilenceID *string `json:"silenceID,omitempty"`
}

func (p *PostSilencesResponse) GetSilenceId() string {
	if p == nil || p.SilenceID == nil {
		return ""
	}
	return *p.SilenceID
}

// WithCondition In our basic model each receiver is uniquely
// identified by its name, which in AlertManager can be routed
// to by the label `alertname`.
func (p *PostableSilence) WithCondition(conditionId string) {
	if p.Matchers == nil {
		p.Matchers = make([]Matcher, 0)
	}
	p.Matchers = append(p.Matchers, Matcher{Name: "conditionId", Value: conditionId})
}

func (p *PostableSilence) WithDuration(dur time.Duration) {
	start := time.Now()
	end := start.Add(dur)
	p.StartsAt = start
	p.EndsAt = end
}

func (p *PostableSilence) WithSilenceId(silenceId string) {
	p.Id = &silenceId
}

func (p *PostableSilence) Must() error {
	if p.Matchers == nil {
		return fmt.Errorf("missing PostableSilence.Matchers")
	}
	if len(p.Matchers) == 0 {
		return fmt.Errorf("missing PostableSilence.Matchers")
	}
	if p.StartsAt.IsZero() {
		return fmt.Errorf("missing PostableSilence.StartsAt")
	}
	if p.EndsAt.IsZero() {
		return fmt.Errorf("missing PostableSilence.EndsAt")
	}
	return nil
}

func ConvertEndpointIdsToRoutingNode(
	endpointList []*alertingv1.AlertEndpoint,
	req *alertingv1.AttachedEndpoints,
	conditionId string,

) (*alertingv1.RoutingNode, error) {
	routingNode := &alertingv1.RoutingNode{
		ConditionId: &corev1.Reference{Id: conditionId},
		FullAttachedEndpoints: &alertingv1.FullAttachedEndpoints{
			Items:              []*alertingv1.FullAttachedEndpoint{},
			InitialDelay:       req.InitialDelay,
			RepeatInterval:     req.RepeatInterval,
			ThrottlingDuration: req.ThrottlingDuration,
			Details:            req.Details,
		},
	}
	for _, endpointItem := range endpointList {
		for _, expectedEndpoint := range req.Items {
			if endpointItem.Id == expectedEndpoint.EndpointId {
				routingNode.FullAttachedEndpoints.Items = append(
					routingNode.FullAttachedEndpoints.Items,
					&alertingv1.FullAttachedEndpoint{
						EndpointId:    endpointItem.Id,
						AlertEndpoint: endpointItem,
						Details:       req.Details,
					})
			}
		}
	}
	return routingNode, nil
}
